import json
import uuid
import csv
import re
import io
from io import BytesIO ,StringIO 
import traceback
from datetime import datetime, timedelta
import pandas as pd
from flask import send_file, make_response , redirect, url_for
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter, landscape, A4
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, Flowable
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
import os
from flask import Flask, request, jsonify, url_for, send_from_directory
from werkzeug.utils import secure_filename
import mysql.connector
from flask import send_from_directory
from mysql.connector import Error
from flask_cors import CORS
from datetime import datetime, date  # Import both datetime and date
import logging
from flask_mysqldb import MySQL
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Table, TableStyle, Spacer, Image, Flowable


def check_table_structure():
    try:
        conn = get_db_connection()
        if not conn:
            print("Database connection failed.")
            return
        
        cursor = conn.cursor()
        
        # Get structure of employee_roles table
        print("EMPLOYEE_ROLES TABLE STRUCTURE:")
        cursor.execute("SHOW COLUMNS FROM employee_roles")
        columns = cursor.fetchall()
        for column in columns:
            print(column)
        
        # Get a sample of data from employee_roles
        print("\nSAMPLE DATA FROM EMPLOYEE_ROLES:")
        cursor.execute("SELECT * FROM employee_roles LIMIT 5")
        rows = cursor.fetchall()
        for row in rows:
            print(row)
        
        cursor.close()
        conn.close()
        
    except Error as e:
        print(f"Error: {e}")
        
def format_date_for_db(date_str):
    """
    Formats a date string from DD-MM-YYYY format to YYYY-MM-DD format for database storage.
    
    Args:
        date_str (str): The date string in DD-MM-YYYY format
        
    Returns:
        str: The formatted date string in YYYY-MM-DD format, or None if invalid
    """
    if not date_str:
        return None
        
    # First, check if the input is not a string
    if not isinstance(date_str, str):
        print(f"Invalid date format - not a string: {date_str}")
        return datetime.datetime.now().strftime('%Y-%m-%d')
    
    # Remove any leading/trailing whitespace
    date_str = date_str.strip()
    
    # Check if it's already in YYYY-MM-DD format
    if re.match(r'^\d{4}-\d{2}-\d{2}$', date_str):
        return date_str
    
    # Parse DD-MM-YYYY format
    try:
        if re.match(r'^\d{2}-\d{2}-\d{4}$', date_str):
            day, month, year = date_str.split('-')
            # Validate date parts
            day_int = int(day)
            month_int = int(month)
            year_int = int(year)
            
            # Basic validation
            if not (1 <= day_int <= 31 and 1 <= month_int <= 12 and 1000 <= year_int <= 9999):
                print(f"Date validation failed: {date_str}")
                return datetime.datetime.now().strftime('%Y-%m-%d')
                
            # Create a datetime object to validate the date
            try:
                datetime.datetime(year_int, month_int, day_int)
                return f"{year}-{month}-{day}"
            except ValueError as e:
                print(f"Invalid date: {e}")
                return datetime.datetime.now().strftime('%Y-%m-%d')
        else:
            print(f"Date string doesn't match expected format: {date_str}")
            return datetime.datetime.now().strftime('%Y-%m-%d')
    except Exception as e:
        print(f"Error processing date {date_str}: {e}")
        return datetime.datetime.now().strftime('%Y-%m-%d')

def sanitize_date_field(date_str):
    """
    Safely converts various date string formats to a standard YYYY-MM-DD format.
    Handles both DD-MM-YYYY and YYYY-MM-DD input formats.
    
    Args:
        date_str: A date string in various formats, or None/empty
    
    Returns:
        A datetime.date object or None if input is invalid
    """
    from datetime import datetime
    
    if not date_str:
        # Return today's date if no date provided
        return datetime.now().date()
    
    # Remove any leading/trailing whitespace
    date_str = str(date_str).strip()
    
    try:
        # Try to parse as DD-MM-YYYY
        if '-' in date_str:
            parts = date_str.split('-')
            if len(parts) == 3:
                # Check if it's DD-MM-YYYY format (first part is day, likely 2 digits)
                if len(parts[0]) <= 2 and int(parts[0]) <= 31:
                    return datetime.strptime(date_str, '%d-%m-%Y').date()
                # Otherwise assume YYYY-MM-DD
                else:
                    return datetime.strptime(date_str, '%Y-%m-%d').date()
        
        # Try to parse ISO format (or similar)
        if ',' in date_str and 'GMT' in date_str:
            # Handle format like 'Thu, 01 May 2025 00:00:00 GMT'
            try:
                return datetime.strptime(date_str, '%a, %d %b %Y %H:%M:%S %Z').date()
            except ValueError:
                # Try without seconds
                return datetime.strptime(date_str, '%a, %d %b %Y %H:%M:%S').date()
        
        # Last attempt - try using dateutil parser which is more flexible
        try:
            from dateutil import parser
            return parser.parse(date_str).date()
        except (ImportError, ValueError):
            # If dateutil is not available or fails, return today
            return datetime.now().date()
            
    except Exception as e:
        print(f"Date parsing error: {e} for input: {date_str}")
        # Return today's date as fallback
        return datetime.now().date()





logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)


app = Flask(__name__)
# Configure CORS properly to allow requests from frontend
CORS(app, resources={r"/*": {"origins": ["http://localhost:3000"], "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"], "allow_headers": ["Content-Type", "Authorization"]}})
# Configure your upload folder and allowed extensions
app.config['UPLOAD_FOLDER'] = './uploads'
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}

# Define role mappings for quick lookup
ROLE_MAPPING = {
  "MD": { "description": "Managing Director/ Founder", "parent": "" },
  "CF": { "description": "Co - Founder", "parent": "MD" },
  "CEO": { "description": "Chief Executive Officer", "parent": "MD" },
  "CTO": { "description": "Chief Technology Officer", "parent": "MD" },
  "COO": { "description": "Chief Operative Officer", "parent": "MD" },
  "CFO": { "description": "Chief Financial Officer", "parent": "MD" },
  "VP": { "description": "Vice President", "parent": "CEO" },
  "AVP": { "description": "Assistant Vice President", "parent": "VP" },
  "SSA": { "description": "Senior Solution Architect", "parent": "AVP" },
  "SA": { "description": "Solution Architect", "parent": "SSA" },
  "SSE": { "description": "Senior Software Engineer", "parent": "SA" },
  "SE": { "description": "Software Engineer", "parent": "SSE" },
  "TRN": { "description": "Traniee", "parent": "SSE" },
  "INTRN": { "description": "Internship Trainee", "parent": "SSE" }
}

# Initialize database tables
def create_tables():
    """Create required tables if they don't exist"""
    try:
        conn = get_db_connection()
        if not conn:
            print("Database connection failed.")
            return
        
        cursor = conn.cursor()
        
        # Create employee_role_allocations table if it doesn't exist
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS employee_role_allocations (
                id INT AUTO_INCREMENT PRIMARY KEY,
                employee_id VARCHAR(50) NOT NULL,
                employee_name VARCHAR(100) NOT NULL,
                role_id VARCHAR(50) NOT NULL,
                role_name VARCHAR(100) NOT NULL,
                allocated_date DATE NOT NULL,
                reporting_person TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_employee_id (employee_id),
                INDEX idx_role_id (role_id),
                INDEX idx_date (allocated_date)
            )
        """)
        
        # Create time_sheet_summary table if it doesn't exist
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS time_sheet_summary (
                summary_id INT AUTO_INCREMENT PRIMARY KEY,
                employee_id VARCHAR(50) NOT NULL,
                employee_name VARCHAR(100) NOT NULL,
                task_id VARCHAR(20),
                task_name VARCHAR(100),
                project_id VARCHAR(20),
                entry_date DATE NOT NULL,
                in_time TIME NOT NULL,
                out_time TIME NOT NULL,
                total_hours DECIMAL(5,2) NOT NULL,
                total_entries INT GENERATED ALWAYS AS (1) STORED,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                INDEX idx_employee (employee_id),
                INDEX idx_project (project_id),
                INDEX idx_date (entry_date)
            )
        """)
        
        conn.commit()
        print("Database tables created/verified successfully")
        
        cursor.close()
        conn.close()
        
    except Error as e:
        print(f"Error creating tables: {e}")

@app.route('/uploads/<filename>')
def uploaded_file(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

# Utility function to convert MySQL rows to dictionaries
def row_to_dict(cursor):
    columns = [col[0] for col in cursor.description]
    return [dict(zip(columns, row)) for row in cursor.fetchall()]

# Format dates for JSON response
def format_dates(item):
    date_fields = ['release_date', 'committed_date', 'initiative_date', 'target_completion_date', 'actual_completion_date', 'allocated_date']
    for field in date_fields:
        if field in item and item[field] and isinstance(item[field], (datetime, date)):
            item[field] = item[field].strftime('%Y-%m-%d')
    return item

# Validate task data
def validate_task_data(data):
    errors = {}
    
    # Check required fields
    required_fields = ['taskId', 'taskName', 'projectId', 'initiativeDate', 'targetCompletionDate', 'taskDescription']
    for field in required_fields:
        if field not in data or not data[field]:
            errors[field] = f"{field} is required"
    
    # Additional validations
    if 'taskName' in data and data['taskName']:
        if len(data['taskName']) < 3:
            errors['taskName'] = "Task name must be at least 3 characters"
        elif len(data['taskName']) > 100:
            errors['taskName'] = "Task name cannot exceed 100 characters"
    
    if 'taskDescription' in data and data['taskDescription']:
        if len(data['taskDescription']) < 10:
            errors['taskDescription'] = "Description must be at least 10 characters"
        elif len(data['taskDescription']) > 500:
            errors['taskDescription'] = "Description cannot exceed 500 characters"
    
    # Date validations
    if 'initiativeDate' in data and 'targetCompletionDate' in data:
        try:
            init_date = datetime.strptime(data['initiativeDate'], '%Y-%m-%d')
            target_date = datetime.strptime(data['targetCompletionDate'], '%Y-%m-%d')
            
            if target_date < init_date:
                errors['targetCompletionDate'] = "Target completion date cannot be before initiative date"
        except ValueError:
            errors['dates'] = "Invalid date format. Use YYYY-MM-DD"
    
    return errors

# Health check endpoint
@app.route('/health', methods=['GET'])
def health_check():
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute('SELECT 1')
        cursor.fetchone()
        cursor.close()
        conn.close()
        return jsonify({"status": "healthy", "database": "connected"})
    except Error as e:
        return jsonify({"status": "unhealthy", "database": "disconnected", "error": str(e)}), 500


# Create uploads directory if it doesn't exist
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

def cursor_result_to_dict(cursor):
    columns = [col[0] for col in cursor.description]
    return [dict(zip(columns, row)) for row in cursor.fetchall()]

def format_dates(item):
    if item is None:
        return item
    
    formatted_item = dict(item)  # Create a copy to avoid modifying the original
    for key, value in formatted_item.items():
        if isinstance(value, (date, datetime)):
            formatted_item[key] = value.strftime('%Y-%m-%d')
    return formatted_item

class Role:
    @staticmethod
    def get_role_by_id(role_id):
        cursor = mysql.connection.cursor()
        query = "SELECT * FROM employee_roles WHERE role_id = %s"
        cursor.execute(query, (role_id,))
        role = cursor.fetchone()
        return role

class Employee:
    @staticmethod
    def get_employee_by_id(employee_id):
        cursor = mysql.connection.cursor()
        query = "SELECT * FROM employees WHERE employee_id = %s"
        cursor.execute(query, (employee_id,))
        employee = cursor.fetchone()
        return employee

# Function to check allowed file types for profile pictures
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# MySQL Database connection setup
def get_db_connection():
    try:
        connection = mysql.connector.connect(
            host='localhost',
            database='employee_management_v2',
            user='root',
            password='password123'
        )
        if connection.is_connected():
            return connection
    except Error as e:
        print(f"Error while connecting to MySQL: {e}")
        return None

# Initialize CORS
CORS(app)  # Enable CORS for all routes

# Route to save product data to MySQL
@app.route('/products', methods=['POST'])
def save_product():
    try:
        # Get data from the request
        data = request.get_json()
        # Extract values from the data
        product_id = data.get('productId')
        product_name = data.get('productName')
        date_of_product = data.get('dateOfProduct')
        product_status = data.get('productstatus')
        product_description = data.get('productDescription')
        product_technical = data.get('productTechnical')
        product_specification = data.get('productSpecification')
        product_framework = data.get('productFramework')
        
        # Validate required fields
        if not all([product_id, product_name, date_of_product, product_status, 
                    product_description, product_technical, product_specification, product_framework]):
            return jsonify({'error': 'Missing required fields'}), 400
        
        # Connect to the database
        conn = get_db_connection()
        if not conn:
            return jsonify({'error': 'Database connection failed'}), 500
        cursor = conn.cursor()
        
        # Insert product into the database
        insert_query = """
            INSERT INTO products (
                product_id, product_name, date_of_product, product_status,
                product_description, product_technical, product_specification,
                product_framework
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        values = (
            product_id,
            product_name,
            date_of_product,
            product_status,
            product_description,
            product_technical,
            product_specification,
            product_framework
        )
        cursor.execute(insert_query, values)
        conn.commit()
        
        return jsonify({
            'message': 'Product saved successfully',
            'productId': product_id
        }), 201
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    
    finally:
        if 'conn' in locals() and conn.is_connected():
            cursor.close()
            conn.close()

@app.route('/add_employee', methods=['POST'])
def add_employee():
    try:
        # Retrieve employee data from the form
        employee_data = request.form.get('employee')
        if not employee_data:
            return jsonify({"error": "Missing employee data."}), 400
        
        try:
            # Parse the JSON data
            employee = json.loads(employee_data)
        except json.JSONDecodeError:
            return jsonify({"error": "Invalid JSON format."}), 400
        
        # Helper function to retrieve field value with optional default
        def get(field, default=None): 
            return employee.get(field, default)
        
        # List of required fields
        required_fields = [
            "employeeId", "firstName", "lastName", "dob", "gender", "nationality",
            "permanentAddress", "communicationAddress", "mobile", "email",
            "fatherName", "motherName", "maritalStatus", "emergencyName",
            "emergencyMobile", "emergencyRelationship", "doj", "joiningLocation"
        ]
        
        # Check if all required fields are present
        for field in required_fields:
            if not get(field):
                return jsonify({"error": f"{field} is required."}), 400
                
        # Validate and format dates
        dob = get("dob")  # Expecting 'DD-MM-YYYY' format
        doj = get("doj")  # Expecting 'DD-MM-YYYY' format
        
        # Validate date formats
        if dob:
            try:
                datetime.strptime(dob, '%d-%m-%Y')
            except ValueError:
                return jsonify({"error": "Invalid DOB format. Use DD-MM-YYYY."}), 400
        if doj:
            try:
                datetime.strptime(doj, '%d-%m-%Y')
            except ValueError:
                return jsonify({"error": "Invalid DOJ format. Use DD-MM-YYYY."}), 400
        
        # Handle profile photo upload (if any)
        profile_pic_url = None
        if 'profilePic' in request.files:
            file = request.files['profilePic']
            if file and file.filename and allowed_file(file.filename):
                ext = file.filename.rsplit('.', 1)[1].lower()
                unique_name = f"{uuid.uuid4().hex}.{ext}"
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], unique_name)
                file.save(filepath)
                profile_pic_url = url_for('uploaded_file', filename=unique_name, _external=True)
            elif file and file.filename:
                return jsonify({"error": "Invalid file type. Only PNG, JPG, JPEG allowed."}), 400
        
        # Database connection
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        cursor = conn.cursor()
        
        # Prepare values for insertion
        values = (
            get("employeeId"),
            get("firstName"),
            get("lastName"),
            dob,  # Stored as 'DD-MM-YYYY' string
            get("gender"),
            get("nationality"),
            get("permanentAddress"),
            get("communicationAddress"),
            get("mobile"),
            get("altMobile", ""),  # altMobile is optional
            get("email"),
            get("qualification", ""),  # qualification is optional
            get("fatherName"),
            get("motherName"),
            get("maritalStatus"),
            get("spouseName", ""),  # spouseName might be empty if not married
            get("emergencyName"),
            get("emergencyMobile"),
            get("emergencyRelationship"),
            doj,  # Stored as 'DD-MM-YYYY' string
            get("joiningLocation"),
            profile_pic_url
        )
        
        # Insert new employee record
        insert_query = """
            INSERT INTO employees (
                employee_id, first_name, last_name, dob, gender, nationality, permanent_address,
                communication_address, mobile, alt_mobile, email, qualification, father_name, mother_name,
                marital_status, spouse_name, emergency_name, emergency_mobile, emergency_relationship,
                doj, joining_location, profile_pic
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """
        try:
            cursor.execute(insert_query, values)
            conn.commit()
        except Error as e:
            print(f"Error inserting employee data: {e}")
            conn.rollback()
            return jsonify({"error": f"Database error: {str(e)}"}), 500
        finally:
            cursor.close()
            conn.close()
            
        return jsonify({
            "status": "success",
            "employeeID": get("employeeId"),
            "profile_photo": profile_pic_url
        }), 200
        
    except Exception as e:
        print(f"âŒ Exception: {e}")
        return jsonify({"error": f"An error occurred: {str(e)}"}), 500
    
@app.route('/add_employee_role', methods=['POST'])
def add_employee_role():
    try:
        role_data = request.get_json()
        
        # Handle both old and new field names
        role_description = role_data.get('roleDescription') or role_data.get('roleName')
        
        if not role_data.get('role_id') or not role_description or not role_data.get('roleType'):
            return jsonify({"error": "Role ID, Role Description, and Role Type are required."}), 400
        
        role_id = role_data['role_id']
        parent_role = role_data.get('parentRole', '')
        role_type = role_data['roleType']
        status = role_data.get('status', 'active')  # Default to 'active' if status not provided
        
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        cursor = conn.cursor()
        
        insert_role_query = """
            INSERT INTO employee_roles (role_id, role_description, parent_role, role_type, status)
            VALUES (%s, %s, %s, %s, %s)
        """
        try:
            cursor.execute(insert_role_query, (role_id, role_description, parent_role, role_type, status))
            conn.commit()
        except Error as e:
            print(f"Error inserting role data: {e}")
            conn.rollback()
            return jsonify({"error": f"Database error: {str(e)}"}), 500
        finally:
            cursor.close()
            conn.close()
        
        return jsonify({"message": "Role details added successfully!"}), 201
    
    except Exception as e:
        print("Error:", e)
        return jsonify({"error": "Something went wrong while adding the role."}), 500

@app.route('/update_employee_role', methods=['PUT'])
def update_employee_role():
    try:
        role_data = request.get_json()
        if not role_data.get('role_id') or not role_data.get('roleDescription') or not role_data.get('roleType'):
            return jsonify({"error": "Role ID, Role Description, and Role Type are required."}), 400
        
        role_id = role_data['role_id']
        role_description = role_data['roleDescription']
        parent_role = role_data.get('parentRole', '')
        role_type = role_data['roleType']
        status = role_data.get('status')  # Get status if provided
        
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        cursor = conn.cursor()
        
        # Construct the query dynamically based on whether status is provided
        if status is not None:
            update_role_query = """
                UPDATE employee_roles
                SET role_description = %s, parent_role = %s, role_type = %s, status = %s
                WHERE role_id = %s
            """
            query_params = (role_description, parent_role, role_type, status, role_id)
        else:
            update_role_query = """
                UPDATE employee_roles
                SET role_description = %s, parent_role = %s, role_type = %s
                WHERE role_id = %s
            """
            query_params = (role_description, parent_role, role_type, role_id)
        
        try:
            cursor.execute(update_role_query, query_params)
            conn.commit()
        except Error as e:
            print(f"Error updating role data: {e}")
            conn.rollback()
            return jsonify({"error": f"Database error: {str(e)}"}), 500
        finally:
            cursor.close()
            conn.close()
        
        return jsonify({"message": "Role details updated successfully!"}), 200
    
    except Exception as e:
        print("Error:", e)
        return jsonify({"error": "Something went wrong while updating the role."}), 500
    
@app.route('/api/employee_roles', methods=['GET'])
def get_employee_roles():
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT * FROM employee_roles")
        roles = cursor.fetchall()
        cursor.close()
        conn.close()
        return jsonify(roles), 200
    except Exception as e:
        print(f"Error fetching employee roles: {e}")
        return jsonify({"error": "Failed to fetch employee roles."}), 500

@app.route('/get_employee_name/<employee_id>', methods=['GET'])
def get_employee_name(employee_id):
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        
        cursor = conn.cursor()
        cursor.execute("SELECT first_name, last_name FROM employees WHERE employee_id = %s", (employee_id,))
        result = cursor.fetchone()
        cursor.close()
        conn.close()
        
        if result:
            return jsonify({'name': f"{result[0]} {result[1]}"})
        
        return jsonify({'name': ''}), 404
    except Exception as e:
        print(f"Error in get_employee_name: {e}")
        return jsonify({"error": "Internal Server Error"}), 500
    
@app.route('/get_employees_by_role/<role_id>', methods=['GET'])
def get_employees_by_role(role_id):
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        
        cursor = conn.cursor()
        
        # Query to find all employees with the specified role
        # This assumes there's a table that maps employees to roles
        # The table structure might vary, so we're providing a flexible approach
        
        # First, check if there's an employee_role_allocations table
        try:
            cursor.execute("""
                SELECT e.employee_id, CONCAT(e.first_name, ' ', e.last_name) as name
                FROM employees e
                JOIN employee_role_allocations era ON e.employee_id = era.employee_id
                WHERE era.role_id = %s
            """, (role_id,))
            
            employees = []
            for row in cursor.fetchall():
                employees.append({
                    "employeeId": row[0],
                    "name": row[1]
                })
            
            cursor.close()
            conn.close()
            
            return jsonify({"employees": employees}), 200
            
        except Exception as table_error:
            # If the first query fails, try an alternative approach
            # Maybe there's a direct role_id column in the employees table
            print(f"First query approach failed: {table_error}. Trying alternative...")
            
            cursor.execute("""
                SELECT employee_id, CONCAT(first_name, ' ', last_name) as name
                FROM employees
                WHERE role_id = %s
            """, (role_id,))
            
            employees = []
            for row in cursor.fetchall():
                employees.append({
                    "employeeId": row[0],
                    "name": row[1]
                })
            
            cursor.close()
            conn.close()
            
            return jsonify({"employees": employees}), 200
            
    except Exception as e:
        print(f"Error in get_employees_by_role: {e}")
        if cursor:
            cursor.close()
        if conn:
            conn.close()
        return jsonify({"error": str(e)}), 500

@app.route('/get_role_name/<role_id>', methods=['GET'])
def get_role_name(role_id):
    try:
        # For roles that are in the ROLE_MAPPING, return the description directly
        # This handles cases like single character inputs like 'S' that aren't valid roles
        if role_id in ROLE_MAPPING:
            return jsonify({'roleDescription': ROLE_MAPPING[role_id]['description']}), 200
            
        # Fetch the role from the database using the role_id
        conn = get_db_connection()
        if not conn:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor()
        
        # Check the structure of the employee_roles table first
        cursor.execute("SHOW COLUMNS FROM employee_roles")
        columns = cursor.fetchall()
        
        # Extract column names
        column_names = [column[0] for column in columns]
        
        # Determine which query to use based on available columns
        if 'role_description' in column_names:
            cursor.execute("SELECT role_description FROM employee_roles WHERE role_id = %s", (role_id,))
            field_name = 'roleDescription'
        elif 'role_name' in column_names:
            cursor.execute("SELECT role_name FROM employee_roles WHERE role_id = %s", (role_id,))
            field_name = 'roleName'
        elif 'rolename' in column_names:  # Try lowercase version
            cursor.execute("SELECT rolename FROM employee_roles WHERE role_id = %s", (role_id,))
            field_name = 'roleName'
        elif 'description' in column_names:  # Try generic description field
            cursor.execute("SELECT description FROM employee_roles WHERE role_id = %s", (role_id,))
            field_name = 'roleDescription'
        else:
            # If we can't determine the right column, return both column list and error
            return jsonify({
                'error': 'Could not determine role name/description column',
                'available_columns': column_names
            }), 500
        
        role = cursor.fetchone()
        cursor.close()
        conn.close()
        
        if role:
            return jsonify({field_name: role[0]}), 200
        else:
            # Check if the role ID might be a partial string that matches a role in ROLE_MAPPING
            for key in ROLE_MAPPING:
                if key.startswith(role_id):
                    return jsonify({'roleDescription': ROLE_MAPPING[key]['description']}), 200
            
            return jsonify({'error': 'Role not found'}), 404
    except Exception as e:
        print(f"Error in get_role_name: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/allocate_role', methods=['POST'])
def allocate_role():
    data = request.get_json()
    
    # Required fields
    employee_id = data.get('employeeId')
    employee_name = data.get('employeeName')
    role_id = data.get('roleId')
    role_name = data.get('roleName')
    allocated_date = data.get('allocatedDate')
    reporting_person = data.get('reportingPerson', '')  # Make it optional with default empty string
    additional_employee_id = data.get('additionalEmployeeId', '') 
    additional_employee_name = data.get('additionalEmployeeName', '') # Optional additional employee ID

    
    # Validate required fields
    if not all([employee_id, employee_name, role_id, role_name, allocated_date]):
        return jsonify({"error": "Missing required fields"}), 400
    
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        
        cursor = conn.cursor()
        
        # Insert into employee_role_allocations table
        query = """
            INSERT INTO employee_role_allocations 
            (employee_id, employee_name, role_id, role_name, allocated_date, reporting_person, additional_employee_id, additional_employee_name)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        cursor.execute(query, (
            employee_id,
            employee_name,
            role_id,
            role_name,
            allocated_date,
            reporting_person,
            additional_employee_id,
            additional_employee_name
        ))
        
        # Also update the employee's role in the employees table
        try:
            update_query = """
                UPDATE employees 
                SET role_id = %s, role_name = %s
                WHERE employee_id = %s
            """
            
            cursor.execute(update_query, (role_id, role_name, employee_id))
            print(f"Updated employee {employee_id} with role {role_name}")
        except Exception as update_error:
            print(f"Error updating employee role in employees table: {update_error}")
            # Continue even if this update fails - the allocation is still valid
        
        conn.commit()
        cursor.close()
        conn.close()
        
        return jsonify({"message": "Role allocation saved successfully"}), 200
    except Exception as e:
        print(f"Error allocating role: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/get_employee_role/<employee_id>', methods=['GET'])
def get_employee_role(employee_id):
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        
        cursor = conn.cursor()
        
        # First check if the employee exists
        cursor.execute("SELECT first_name, last_name FROM employees WHERE employee_id = %s", (employee_id,))
        employee = cursor.fetchone()
        
        if not employee:
            cursor.close()
            conn.close()
            return jsonify({"error": "Employee not found"}), 404
        
        # Get the employee's role from the employee_role_allocations table
        # We're getting the most recent role allocation for this employee
        cursor.execute("""
            SELECT role_id, role_name 
            FROM employee_role_allocations 
            WHERE employee_id = %s 
            ORDER BY allocated_date DESC 
            LIMIT 1
        """, (employee_id,))
        
        role = cursor.fetchone()
        cursor.close()
        conn.close()
        
        if role:
            return jsonify({
                "roleId": role[0],
                "roleName": role[1]
            }), 200
        else:
            # If no role allocation found, return empty strings
            return jsonify({
                "roleId": "",
                "roleName": ""
            }), 200
            
    except Exception as e:
        print(f"Error in get_employee_role: {e}")
        return jsonify({"error": str(e)}), 500

    
    
@app.route('/get_role_hierarchy/<role_id>', methods=['GET'])
def get_role_hierarchy(role_id):
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        
        cursor = conn.cursor()
        
        # First check if the role exists in employee_roles
        cursor.execute("SELECT role_id FROM employee_roles WHERE role_id = %s", (role_id,))
        role = cursor.fetchone()
        
        if not role:
            cursor.close()
            conn.close()
            return jsonify({"error": "Role not found"}), 404
        
        # Check if role_hierarchy table exists and has the necessary structure
        try:
            cursor.execute("""
                SELECT parent_role_id 
                FROM role_hierarchy 
                WHERE role_id = %s
            """, (role_id,))
            
            hierarchy = cursor.fetchone()
            
            if hierarchy and hierarchy[0]:
                parent_role_id = hierarchy[0]
                
                # Get the parent role name
                cursor.execute("SHOW COLUMNS FROM employee_roles")
                columns = cursor.fetchall()
                column_names = [column[0] for column in columns]
                
                if 'role_description' in column_names:
                    cursor.execute("SELECT role_description FROM employee_roles WHERE role_id = %s", (parent_role_id,))
                    field_name = 'parentRoleName'
                elif 'role_name' in column_names:
                    cursor.execute("SELECT role_name FROM employee_roles WHERE role_id = %s", (parent_role_id,))
                    field_name = 'parentRoleName'
                else:
                    field_name = 'parentRoleName'
                    cursor.execute("SELECT role_id FROM employee_roles WHERE role_id = %s", (parent_role_id,))
                
                parent_role = cursor.fetchone()
                
                cursor.close()
                conn.close()
                
                if parent_role:
                    return jsonify({
                        "parentRoleId": parent_role_id,
                        field_name: parent_role[0]
                    }), 200
                else:
                    return jsonify({
                        "parentRoleId": parent_role_id,
                        field_name: ""
                    }), 200
            else:
                cursor.close()
                conn.close()
                return jsonify({
                    "parentRoleId": "",
                    "parentRoleName": ""
                }), 200
                
        except Exception as table_error:
            # If the role_hierarchy table doesn't exist or there's another issue,
            # we'll return an empty response rather than an error
            print(f"Warning in get_role_hierarchy: {table_error}")
            cursor.close()
            conn.close()
            return jsonify({
                "parentRoleId": "",
                "parentRoleName": ""
            }), 200
            
    except Exception as e:
        print(f"Error in get_role_hierarchy: {e}")
        return jsonify({"error": str(e)}), 500



@app.route('/get_employee_status/<employee_id>', methods=['GET'])
def get_employee_status(employee_id):
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({'error': 'Database connection failed'}), 500

        cursor = connection.cursor(dictionary=True)

        # First, get the employee details from the employees table to get the doj
        employee_query = """
            SELECT doj FROM employees WHERE employee_id = %s
        """
        cursor.execute(employee_query, (employee_id,))
        employee_result = cursor.fetchone()

        if not employee_result:
            return jsonify({'error': 'Employee not found'}), 404

        # Then get the role allocation data
        role_query = """
            SELECT 
                employee_name, 
                role_name,
                reporting_person
            FROM employee_role_allocations
            WHERE employee_id = %s
            ORDER BY allocated_date DESC, id DESC
            LIMIT 1
        """
        cursor.execute(role_query, (employee_id,))
        role_result = cursor.fetchone()

        if not role_result:
            # If we have employee but no role data, still return employee with doj
            doj = employee_result['doj']
            # Format date if it's a date object or parse it if it's a string
            if doj is None:
                doj = ""  # Set to empty string if NULL in database
            elif isinstance(doj, date) and not isinstance(doj, datetime):
                doj = doj.strftime('%d/%m/%Y')
            elif isinstance(doj, str):
                # Try to parse the string date in different formats
                try:
                    # First try DD-MM-YYYY (format used in add_employee)
                    date_obj = datetime.strptime(doj, '%d-%m-%Y')
                    doj = date_obj.strftime('%d/%m/%Y')
                except ValueError:
                    try:
                        # Then try YYYY-MM-DD (MySQL default)
                        date_obj = datetime.strptime(doj, '%Y-%m-%d')
                        doj = date_obj.strftime('%d/%m/%Y')
                    except ValueError:
                        # If all parsing fails, return as is
                        pass
                
            return jsonify({
                'name': '',
                'role_name': '',
                'reporting_person': '',
                'joining_date': doj
            })

        # Format DOJ for response
        doj = employee_result['doj']
        # Format date if it's a date object or parse it if it's a string
        if doj is None:
            doj = ""  # Set to empty string if NULL in database
        elif isinstance(doj, date) and not isinstance(doj, datetime):
            doj = doj.strftime('%d/%m/%Y')
        elif isinstance(doj, str):
            # Try to parse the string date in different formats
            try:
                # First try DD-MM-YYYY (format used in add_employee)
                date_obj = datetime.strptime(doj, '%d-%m-%Y')
                doj = date_obj.strftime('%d/%m/%Y')
            except ValueError:
                try:
                    # Then try YYYY-MM-DD (MySQL default)
                    date_obj = datetime.strptime(doj, '%Y-%m-%d')
                    doj = date_obj.strftime('%d/%m/%Y')
                except ValueError:
                    # If all parsing fails, return as is
                    pass

        return jsonify({
            'name': role_result['employee_name'],
            'role_name': role_result['role_name'],
            'reporting_person': role_result['reporting_person'] or '',
            'joining_date': doj
        })

    except Exception as e:
        print(f"Error fetching employee status: {e}")
        return jsonify({'error': f'Error fetching employee status: {str(e)}'}), 500
    finally:
        if 'connection' in locals() and connection.is_connected():
            cursor.close()
            connection.close()


@app.route('/update_employee_status/<string:employee_id>', methods=['POST'])
def update_employee_status(employee_id):
    try:
        status_data = request.get_json()
        if not status_data:
            return jsonify({"error": "No data provided."}), 400
            
        status = status_data.get('status')
        status_date = status_data.get('statusDate')  # Expecting 'DD/MM/YYYY' format
        remarks = status_data.get('remarks', '')
        
        if not status or not status_date:
            return jsonify({"error": "Status and statusDate are required."}), 400
            
        # Convert statusDate from DD/MM/YYYY to YYYY-MM-DD
        try:
            parsed_date = datetime.strptime(status_date, '%d/%m/%Y')
            formatted_date = parsed_date.strftime('%Y-%m-%d')
        except ValueError:
            return jsonify({"error": "Invalid date format for statusDate. Use DD/MM/YYYY."}), 400
            
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        cursor = conn.cursor()
        
        insert_query = """
            INSERT INTO employee_status (employee_id, status, status_date, remarks)
            VALUES (%s, %s, %s, %s)
            ON DUPLICATE KEY UPDATE
            status = VALUES(status),
            status_date = VALUES(status_date),
            remarks = VALUES(remarks)
        """
        
        cursor.execute(insert_query, (employee_id, status, formatted_date, remarks))
        conn.commit()
        
        cursor.close()
        conn.close()
        
        return jsonify({"message": "Status updated successfully!"}), 200
        
    except Exception as e:
        print("Error:", e)
        return jsonify({"error": "Something went wrong while updating the status."}), 500

@app.route('/clients', methods=['POST'])
def save_client():
    try:
        # Get data from the request
        data = request.get_json()
        
        # Extract values from the data
        client_id = data.get('clientId')
        client_name = data.get('clientName')
        client_description = data.get('clientDescription')
        client_address = data.get('clientAddress')
        communication_email = data.get('communicationEmail')
        contact_name = data.get('contactName')
        contact_designation = data.get('contactDesignation')
        contact_mobile = data.get('contactMobile')
        contact_email = data.get('contactEmail')
        reporting_to = data.get('reportingTo')
        
        # Validate required fields
        if not all([client_id, client_name, client_description, client_address, communication_email,
                    contact_name, contact_designation, contact_mobile, contact_email, reporting_to]):
            return jsonify({'error': 'Missing required fields'}), 400
            
        # Connect to the database
        conn = get_db_connection()
        if not conn:
            return jsonify({'error': 'Database connection failed'}), 500
        cursor = conn.cursor()
        
        # Insert client into the database
        insert_query = """
            INSERT INTO clients (
                client_id, client_name, client_description, client_address,
                communication_email, contact_name, contact_designation,
                contact_mobile, contact_email, reporting_to
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        values = (
            client_id,
            client_name,
            client_description,
            client_address,
            communication_email,
            contact_name,
            contact_designation,
            contact_mobile,
            contact_email,
            reporting_to
        )
        
        cursor.execute(insert_query, values)
        conn.commit()
        
        return jsonify({
            'message': 'Client created successfully',
            'clientId': client_id
        }), 201
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500
        
    finally:
        if 'conn' in locals() and conn.is_connected():
            cursor.close()
            conn.close()

@app.route('/get_client_name/<client_id>', methods=['GET'])
def get_client_name(client_id):
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed"}), 500
        cursor = conn.cursor(dictionary=True)
        query = "SELECT client_name FROM clients WHERE client_id = %s"
        cursor.execute(query, (client_id,))
        result = cursor.fetchone()
        cursor.close()
        conn.close()
        if result:
            return jsonify(result), 200
        else:
            return jsonify({"error": "Client not found"}), 404
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/get_product_name/<product_id>', methods=['GET'])
def get_product_name(product_id):
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed"}), 500
        cursor = conn.cursor(dictionary=True)
        query = "SELECT product_name FROM products WHERE product_id = %s"
        cursor.execute(query, (product_id,))
        result = cursor.fetchone()
        cursor.close()
        conn.close()
        if result:
            return jsonify(result), 200
        else:
            return jsonify({"error": "Product not found"}), 404
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# Route to save project data to MySQL
@app.route('/projects', methods=['POST'])
def save_project():
    try:
        data = request.get_json()
        project_id = data.get('projectId')
        project_name = data.get('projectName')
        project_client_id = data.get('projectClientId')
        client_name = data.get('clientName')
        product_id = data.get('productId')
        product_name = data.get('productName')
        managed_by = data.get('managedBy')
        estimated_cost = data.get('estimatedCost')
        completion_days = data.get('completionDays')
        release_date_str = data.get('releaseDate')
        committed_date_str = data.get('committedDate')
        description = data.get('description')
        
        if not all([project_id, project_name, project_client_id, client_name, product_id, product_name, managed_by, 
                    estimated_cost, completion_days, release_date_str, committed_date_str]):
            return jsonify({'error': 'Missing required fields'}), 400
            
        # Convert dates from DD-MM-YYYY to YYYY-MM-DD
        release_date = datetime.strptime(release_date_str, '%d-%m-%Y').date()
        committed_date = datetime.strptime(committed_date_str, '%d-%m-%Y').date()
        
        conn = get_db_connection()
        if not conn:
            return jsonify({'error': 'Database connection failed'}), 500
        cursor = conn.cursor()
        
        insert_query = """
            INSERT INTO projects (
                project_id, project_name, project_client_id, client_name, product_id, product_name,
                managed_by, estimated_cost, completion_days, release_date, committed_date, description
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        values = (
            project_id,
            project_name,
            project_client_id,
            client_name,
            product_id,
            product_name,
            managed_by,
            estimated_cost,
            completion_days,
            release_date,
            committed_date,
            description
        )
        
        cursor.execute(insert_query, values)
        conn.commit()
        
        return jsonify({
            'message': 'Project created successfully',
            'projectId': project_id
        }), 201
        
    except ValueError as ve:
        print(f"ValueError: {ve}")
        return jsonify({'error': 'Invalid date format. Please use DD-MM-YYYY.'}), 400
        
    except Error as e:
        print(f"Database error: {e}")
        return jsonify({'error': 'Database error occurred'}), 500
        
    except Exception as e:
        print(f"An error occurred: {e}")
        return jsonify({'error': str(e)}), 500
        
    finally:
        if 'conn' in locals() and conn.is_connected():
            cursor.close()
            conn.close()

@app.route('/api/employees', methods=['GET'])
def get_employees():
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed"}), 500
        cursor = conn.cursor(dictionary=True)
        
        # Fetch employees with their role names
        cursor.execute("""
            SELECT 
                employee_id, 
                CONCAT(first_name, ' ', last_name) AS employee_name, 
                profile_pic AS profile_photo, 
                doj AS date_joined, 
                email, 
                mobile AS phone,
                role_name
            FROM employees
        """)
        
        employees = cursor.fetchall()
        cursor.close()
        conn.close()
        
        # Format date_joined if it's a valid date string
        for employee in employees:
            if employee['date_joined']:
                try:
                    if isinstance(employee['date_joined'], date) and not isinstance(employee['date_joined'], datetime):
                        employee['date_joined'] = employee['date_joined'].strftime('%d-%m-%Y')
                    elif isinstance(employee['date_joined'], str):
                        # If it's a string, parse it and then format
                        date_obj = datetime.strptime(employee['date_joined'], '%Y-%m-%d')
                        employee['date_joined'] = date_obj.strftime('%d-%m-%Y')
                except (ValueError, TypeError):
                    pass
                    
        return jsonify(employees)
        
    except mysql.connector.Error as e:
        print(f"Database error: {e}")
        return jsonify({"error": f"Database error: {str(e)}"}), 500
        
    except Exception as e:
        print(f"An error occurred: {e}")
        return jsonify({"error": f"An error occurred: {str(e)}"}), 500

@app.route('/api/roles', methods=['GET'])
def get_roles():
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed"}), 500
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT role_id, role_name FROM employee_roles")
        roles = cursor.fetchall()
        cursor.close()
        conn.close()
        return jsonify(roles)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/employees/<employee_id>', methods=['DELETE'])
def delete_employee(employee_id):
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # First check if employee has any role allocations
        cursor.execute("SELECT COUNT(*) FROM role_allocations WHERE employee_id = %s", (employee_id,))
        role_count = cursor.fetchone()[0]
        
        if role_count > 0:
            conn.close()
            return jsonify({
                'error': 'Cannot delete employee with active role allocations',
                'message': f'This employee has {role_count} role allocation(s). Please remove these first.'
            }), 409  # Conflict status code
        
        # Check if employee has task allocations
        cursor.execute("SELECT COUNT(*) FROM task_allocations WHERE employee_id = %s", (employee_id,))
        task_count = cursor.fetchone()[0]
        
        if task_count > 0:
            conn.close()
            return jsonify({
                'error': 'Cannot delete employee with task allocations',
                'message': f'This employee has {task_count} task allocation(s). Please remove these first.'
            }), 409
        
        # Check for timesheet entries
        cursor.execute("SELECT COUNT(*) FROM timesheet_entries WHERE employee_id = %s", (employee_id,))
        timesheet_count = cursor.fetchone()[0]
        
        if timesheet_count > 0:
            conn.close()
            return jsonify({
                'error': 'Cannot delete employee with timesheet entries',
                'message': f'This employee has {timesheet_count} timesheet entries. Please remove these first.'
            }), 409
        
        # Now we can safely delete the employee
        cursor.execute("DELETE FROM employees WHERE employee_id = %s", (employee_id,))
        conn.commit()
        conn.close()
        
        return jsonify({'message': 'Employee deleted successfully'}), 200
    except Exception as e:
        # Log the actual error for debugging
        print(f"Error deleting employee {employee_id}: {str(e)}")
        return jsonify({
            'error': 'Failed to delete employee',
            'message': 'This employee may have dependencies in the system. Please check if they have role allocations, tasks, or timesheets.'
        }), 400
    
@app.route('/api/employees/<employee_id>', methods=['GET'])
def get_employee_by_id(employee_id):
    try:
        print(f"Fetching employee with ID: {employee_id}")
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed"}), 500
        
        cursor = conn.cursor(dictionary=True)
        
        # First, check the table structure - helps with debugging
        print("Checking employees table structure...")
        cursor.execute("DESCRIBE employees")
        columns = cursor.fetchall()
        column_names = [col['Field'] for col in columns]
        print(f"Available columns: {column_names}")
        
        # Build a dynamic query based on columns that actually exist
        existing_columns = []
        alias_mapping = {
            'first_name': 'first_name',
            'last_name': 'last_name',
            'employee_id': 'employee_id',
            'profile_pic': 'profile_photo',
            'role_name': 'roleName',
            'father_name': 'fatherName',
            'mother_name': 'motherName',
            'marital_status': 'maritalStatus',
            'spouse_name': 'spouseName',
            'permanent_address': 'permanentAddress',
            'communication_address': 'communicationAddress',
            'emergency_contact_person': 'emergencyContactPerson',
            'emergency_name': 'emergencyName',
            'emergency_contact_no': 'emergencyMobile',
            'emergency_mobile': 'emergencyMobile',
            'emergency_relationship': 'emergencyRelationship',
            'alt_mobile': 'altMobile',
            'joining_location': 'joiningLocation',
            'doj': 'doj',
            'email': 'email',
            'mobile': 'mobile',
            'gender': 'gender',
            'dob': 'dob',
            'nationality': 'nationality',
            'qualification': 'qualification',
            'created_at': 'created_at'
        }
        
        select_parts = ["employee_id"]  # Always include employee_id
        
        # Add CONCAT for name if both first_name and last_name exist
        if 'first_name' in column_names and 'last_name' in column_names:
            select_parts.append("CONCAT(first_name, ' ', last_name) AS name")
        
        # Add other columns if they exist in the table
        for db_col, api_col in alias_mapping.items():
            if db_col in column_names and db_col != 'employee_id':  # employee_id already added
                if db_col == api_col:
                    select_parts.append(db_col)
                else:
                    select_parts.append(f"{db_col} AS {api_col}")
        
        # Build the final query
        query = f"""
            SELECT 
                {', '.join(select_parts)}
            FROM employees
            WHERE employee_id = %s
        """
        
        print(f"Executing query: {query}")
        cursor.execute(query, (employee_id,))
        employee = cursor.fetchone()
        
        if not employee:
            cursor.close()
            conn.close()
            print(f"Employee not found: {employee_id}")
            return jsonify({"error": "Employee not found"}), 404
        
        # Format date fields for JSON
        for key, value in employee.items():
            if isinstance(value, (date, datetime)):
                employee[key] = value.strftime('%Y-%m-%d')
            elif value is None:
                # Provide default values for None fields
                employee[key] = ""
        
        # If role_name/roleName is empty or "Unassigned", check for most recent role from employee_role_allocations
        if not employee.get('roleName') or employee.get('roleName') == "Unassigned":
            try:
                print("Role name is empty, checking recent role allocations...")
                role_query = """
                    SELECT role_id, role_name 
                    FROM employee_role_allocations 
                    WHERE employee_id = %s 
                    ORDER BY allocated_date DESC 
                    LIMIT 1
                """
                cursor.execute(role_query, (employee_id,))
                recent_role = cursor.fetchone()
                
                if recent_role and recent_role['role_name']:
                    print(f"Found more recent role from allocations: {recent_role['role_name']}")
                    employee['roleName'] = recent_role['role_name']
                    employee['role_id'] = recent_role['role_id']
                    
                    # Also update the employee record for future requests
                    update_query = """
                        UPDATE employees 
                        SET role_id = %s, role_name = %s
                        WHERE employee_id = %s
                    """
                    cursor.execute(update_query, (recent_role['role_id'], recent_role['role_name'], employee_id))
                    conn.commit()
                    print(f"Updated employee record with role {recent_role['role_name']}")
            except Exception as role_err:
                print(f"Error retrieving role allocation: {str(role_err)}")
                # Continue even if this fails - we'll use what we have
        
        # Add default values for missing fields that the frontend expects
        expected_fields = [
            'employee_id', 'name', 'roleName', 'profile_photo', 'dob', 'mobile', 
            'altMobile', 'email', 'nationality', 'address', 'permanentAddress', 'communicationAddress',
            'qualification', 'department', 'spouseName', 'emergencyName', 'emergencyContactPerson',
            'emergencyMobile', 'emergencyRelationship', 'fatherName', 'motherName', 
            'gender', 'maritalStatus', 'joiningLocation', 'created_at'
        ]
        
        for field in expected_fields:
            if field not in employee:
                employee[field] = ""
            
        print(f"Successfully fetched employee data for ID: {employee_id}")
        cursor.close()
        conn.close()
        
        return jsonify(employee)
        
    except Exception as e:
        print(f"Error retrieving employee {employee_id}: {str(e)}")
        
        # Return detailed error information in debug mode
        error_info = {
            "error": str(e),
            "details": "An error occurred while retrieving employee data"
        }
        
        return jsonify(error_info), 500

@app.route('/api/product-details/<product_id>', methods=['GET'])
def product_details(product_id):
    try:
        # Get database connection
        conn = get_db_connection()
        if not conn:
            return jsonify({'error': 'Database connection failed'}), 500
        
        # Create dictionary cursor
        cursor = conn.cursor(dictionary=True)
        
        # Query for product details
        product_query = """
            SELECT * FROM products WHERE product_id = %s
        """
        
        # Execute product query
        cursor.execute(product_query, (product_id,))
        product = cursor.fetchone()
        
        if not product:
            cursor.close()
            conn.close()
            return jsonify({"error": "Product not found"}), 404
        
        # Find projects associated with this product
        project_query = """
            SELECT * FROM projects WHERE product_id = %s
        """
        
        # Execute project query
        cursor.execute(project_query, (product_id,))
        projects = cursor.fetchall()
        
        # Find clients associated with these projects
        clients = []
        if projects:
            client_ids = [project['project_client_id'] for project in projects]
            
            # Build placeholders for IN clause
            placeholders = ', '.join(['%s'] * len(client_ids))
            
            client_query = f"""
                SELECT * FROM clients WHERE client_id IN ({placeholders})
            """
            
            # Execute client query
            cursor.execute(client_query, tuple(client_ids))
            clients = cursor.fetchall()
        
        # Format dates for JSON
        # Format the product dates
        formatted_product = {}
        for key, value in product.items():
            if isinstance(value, (date, datetime)):
                formatted_product[key] = value.strftime('%Y-%m-%d')
            else:
                formatted_product[key] = value
        
        # Format the project dates
        formatted_projects = []
        for project in projects:
            formatted_project = {}
            for key, value in project.items():
                if isinstance(value, (date, datetime)):
                    formatted_project[key] = value.strftime('%Y-%m-%d')
                else:
                    formatted_project[key] = value
            formatted_projects.append(formatted_project)
        
        # Format the client dates
        formatted_clients = []
        for client in clients:
            formatted_client = {}
            for key, value in client.items():
                if isinstance(value, (date, datetime)):
                    formatted_client[key] = value.strftime('%Y-%m-%d')
                else:
                    formatted_client[key] = value
            formatted_clients.append(formatted_client)
        
        # Close cursor and connection
        cursor.close()
        conn.close()
        
        # Return combined data
        result = {
            "product": formatted_product,
            "projects": formatted_projects,
            "clients": formatted_clients
        }
        
        return jsonify(result)
    
    except Exception as e:
        print(f"Error in product details: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/product-update/<product_id>', methods=['PUT'])
def update_product(product_id):
    """Update a product's information"""
    try:
        data = request.get_json()
        
        # Extract values from the data
        product_name = data.get('productName')
        product_status = data.get('productStatus')
        product_description = data.get('productDescription')
        product_technical = data.get('productTechnical')
        product_specification = data.get('productSpecification')
        product_framework = data.get('productFramework')
        
        # Connect to the database
        conn = get_db_connection()
        if not conn:
            return jsonify({'error': 'Database connection failed'}), 500
        cursor = conn.cursor()
        
        # Update product in the database
        update_query = """
            UPDATE products 
            SET 
                product_name = %s, 
                product_status = %s, 
                product_description = %s, 
                product_technical = %s, 
                product_specification = %s, 
                product_framework = %s
            WHERE product_id = %s
        """
        
        values = (
            product_name,
            product_status,
            product_description,
            product_technical,
            product_specification,
            product_framework,
            product_id
        )
        
        cursor.execute(update_query, values)
        conn.commit()
        
        cursor.close()
        conn.close()
        
        return jsonify({
            'message': 'Product updated successfully',
            'productId': product_id
        }), 200
        
    except Exception as e:
        print(f"Error in update_product: {str(e)}")
        return jsonify({'error': str(e)}), 500
    
    
@app.route('/api/product-report', methods=['GET'])
def get_product_report():
    product_id = request.args.get('productId', '')
    
    connection = get_db_connection()
    if connection is None:
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = connection.cursor()
        
        if product_id:
            query = """
            SELECT product_id, product_name, date_of_product, product_status
            FROM products
            WHERE product_id LIKE %s
            """
            cursor.execute(query, (f"%{product_id}%",))
        else:
            query = """
            SELECT product_id, product_name, date_of_product, product_status
            FROM products
            LIMIT 1000
            """
            cursor.execute(query)
        
        products = cursor_result_to_dict(cursor)
        formatted_products = [format_dates(product) for product in products]
        
        return jsonify(formatted_products)
    except Error as e:
        return jsonify({"error": str(e)}), 500
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()

@app.route('/api/client-report', methods=['GET'])
def get_client_report():
    client_id = request.args.get('clientId', '')
    
    connection = get_db_connection()
    if connection is None:
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = connection.cursor()
        
        if client_id:
            query = """
            SELECT client_id, client_name, client_address, communication_email, contact_mobile
            FROM clients
            WHERE client_id LIKE %s
            """
            cursor.execute(query, (f"%{client_id}%",))
        else:
            query = """
            SELECT client_id, client_name, client_address, communication_email, contact_mobile
            FROM clients
            LIMIT 1000
            """
            cursor.execute(query)
        
        clients = cursor_result_to_dict(cursor)
        
        # Remove the CORS headers and just return the response
        return jsonify(clients)
    except Error as e:
        return jsonify({"error": str(e)}), 500
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()

# Project Report Endpoint
@app.route('/api/project-report', methods=['GET'])
def get_project_report():
    project_id = request.args.get('projectId', '')
    
    connection = get_db_connection()
    if connection is None:
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = connection.cursor()
        
        if project_id:
            query = """
            SELECT project_id, project_name, description, release_date, committed_date, estimated_cost
            FROM projects
            WHERE project_id LIKE %s
            """
            cursor.execute(query, (f"%{project_id}%",))
        else:
            query = """
            SELECT project_id, project_name, description, release_date, committed_date, estimated_cost
            FROM projects
            LIMIT 1000
            """
            cursor.execute(query)
        
        projects = cursor_result_to_dict(cursor)
        formatted_projects = [format_dates(project) for project in projects]
        
        return jsonify(formatted_projects)
    except Error as e:
        return jsonify({"error": str(e)}), 500
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()
    
    
@app.route('/api/check-schema', methods=['GET'])
def check_schema():
    conn = None
    cursor = None
    try:
        # Get database connection
        conn = get_db_connection()
        if not conn:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor(dictionary=True)
        
        # Get all tables in the database
        cursor.execute("SHOW TABLES")
        tables = cursor.fetchall()
        
        schema_info = {}
        
        # For each table, get column information
        for table_row in tables:
            table_name = list(table_row.values())[0]  # Get table name from the result
            cursor.execute(f"DESCRIBE {table_name}")
            columns = cursor.fetchall()
            
            # Extract column names and types
            column_info = []
            for col in columns:
                column_info.append({
                    'name': col['Field'],
                    'type': col['Type'],
                    'null': col['Null'],
                    'key': col['Key'],
                    'default': col['Default'],
                    'extra': col['Extra']
                })
            
            schema_info[table_name] = column_info
        
        return jsonify({
            'tables': [list(table.values())[0] for table in tables],
            'schema': schema_info
        })
        
    except Exception as e:
        import traceback
        print(f"Error checking schema: {str(e)}")
        print(traceback.format_exc())
        return jsonify({'error': str(e)}), 500
        
    finally:
        if cursor:
            cursor.close()
        if conn and conn.is_connected():
            conn.close()
            
@app.route('/api/product/<product_id>', methods=['GET'])
def get_product_detail(product_id):
    connection = get_db_connection()
    if connection is None:
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = connection.cursor()
        
        query = """
        SELECT *
        FROM products
        WHERE product_id = %s
        """
        cursor.execute(query, (product_id,))
        
        products = cursor_result_to_dict(cursor)
        if products:
            formatted_product = format_dates(products[0])
            return jsonify(formatted_product)
        else:
            return jsonify({"error": "Product not found"}), 404
    except Error as e:
        return jsonify({"error": str(e)}), 500
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()
            
@app.route('/api/client/<client_id>', methods=['GET'])
def get_client_detail(client_id):
    connection = get_db_connection()
    if connection is None:
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = connection.cursor()
        
        query = """
        SELECT *
        FROM clients
        WHERE client_id = %s
        """
        cursor.execute(query, (client_id,))
        
        clients = cursor_result_to_dict(cursor)
        if clients:
            formatted_client = format_dates(clients[0])
            return jsonify(formatted_client)
        else:
            return jsonify({"error": "Client not found"}), 404
    except Error as e:
        return jsonify({"error": str(e)}), 500
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()
            

# Project detail endpoint (for View button)
@app.route('/api/project/<project_id>', methods=['GET'])
def get_project_detail(project_id):
    connection = get_db_connection()
    if connection is None:
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = connection.cursor()
        
        query = """
        SELECT *
        FROM projects
        WHERE project_id = %s
        """
        cursor.execute(query, (project_id,))
        
        projects = cursor_result_to_dict(cursor)
        if projects:
            formatted_project = format_dates(projects[0])
            return jsonify(formatted_project)
        else:
            return jsonify({"error": "Project not found"}), 404
    except Error as e:
        return jsonify({"error": str(e)}), 500
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()
            
@app.route('/projects', methods=['GET'])
def get_all_projects():
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed"}), 500

        cursor = conn.cursor(dictionary=True)
        query = """SELECT project_id, project_name, project_client_id, client_name, 
                  product_id, product_name, managed_by, estimated_cost, completion_days, 
                  release_date, committed_date, description
                  FROM projects"""
        cursor.execute(query)
        projects = cursor.fetchall()

        formatted_projects = [format_dates(project) for project in projects]
        return jsonify(formatted_projects), 200

    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'conn' in locals() and conn.is_connected():
            conn.close()
# Function to log downloads in the database
def log_download(report_type, entity_id, download_format, record_count, filter_params=None):
    """
    Log download activity to the database
    
    Args:
        report_type (str): Type of report ('project', 'product', 'client')
        entity_id (str): ID of the specific entity or None for multiple
        download_format (str): Format of the download ('csv', 'pdf')
        record_count (int): Number of records in the report
        filter_params (dict, optional): Dictionary of filter parameters
    """
    try:
        conn = get_db_connection()
        if not conn:
            print("Failed to connect to database for logging download")
            return False
            
        cursor = conn.cursor()
        
        # Get user information
        user_id = request.args.get('userId', None)  # Assuming userId might be passed as a parameter
        ip_address = request.remote_addr
        
        # Convert filter params to JSON string if provided
        filter_json = json.dumps(filter_params) if filter_params else None
        
        # Insert download log
        insert_query = """
            INSERT INTO download_logs (
                user_id, report_type, entity_id, download_format, 
                ip_address, download_date, filter_params, record_count
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        values = (
            user_id,
            report_type,
            entity_id,
            download_format,
            ip_address,
            datetime.now(),
            filter_json,
            record_count
        )
        
        cursor.execute(insert_query, values)
        conn.commit()
        
        return True
        
    except Exception as e:
        print(f"Error logging download: {str(e)}")
        return False
        
    finally:
        if 'conn' in locals() and conn.is_connected():
            cursor.close()
            conn.close()

@app.route('/api/download-project-report/<format>', methods=['GET'])
def download_project_report(format):
    project_id = request.args.get('projectId', '')
    filter_params = {
        'projectId': project_id
    }
    
    print(f"Downloading project report in {format} format with projectId: '{project_id}'")
    
    conn = get_db_connection()
    if conn is None:
        print("Database connection failed when downloading project report")
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = conn.cursor(dictionary=True)
        
        # Debug: Get all project IDs to see what's available
        cursor.execute("SELECT project_id FROM projects LIMIT 10")
        available_projects = cursor.fetchall()
        print(f"Available project IDs: {[p['project_id'] for p in available_projects]}")
        
        if project_id:
            print(f"Trying both exact and partial matches for project ID: {project_id}")
            projects = None
            
            # Try exact match first
            query = """
            SELECT project_id, project_name, project_client_id, client_name, product_id, 
                  product_name, managed_by, estimated_cost, completion_days, 
                  release_date, committed_date, description
            FROM projects
            WHERE project_id = %s
            """
            cursor.execute(query, (project_id,))
            projects = cursor.fetchall()
            
            # If no exact match found, try LIKE match
            if not projects:
                print(f"No exact match found, trying LIKE match for: {project_id}")
                query = """
                SELECT project_id, project_name, project_client_id, client_name, product_id, 
                      product_name, managed_by, estimated_cost, completion_days, 
                      release_date, committed_date, description
                FROM projects
                WHERE project_id LIKE %s
                """
                cursor.execute(query, (f"%{project_id}%",))
                projects = cursor.fetchall()
            
            # If P format is provided but database uses PRO format
            if not projects and project_id.startswith('P'):
                potential_pro_id = 'PRO' + project_id[1:]
                print(f"Trying PRO format: {potential_pro_id}")
                query = """
                SELECT project_id, project_name, project_client_id, client_name, product_id, 
                      product_name, managed_by, estimated_cost, completion_days, 
                      release_date, committed_date, description
                FROM projects
                WHERE project_id = %s OR project_id LIKE %s
                """
                cursor.execute(query, (potential_pro_id, f"%{project_id}%"))
                projects = cursor.fetchall()
            
            # If still no match, try number matching
            if not projects and any(c.isdigit() for c in project_id):
                # Extract digits from project_id
                digits = ''.join(c for c in project_id if c.isdigit())
                print(f"Trying to match by number part: {digits}")
                query = """
                SELECT project_id, project_name, project_client_id, client_name, product_id, 
                      product_name, managed_by, estimated_cost, completion_days, 
                      release_date, committed_date, description
                FROM projects
                WHERE project_id LIKE %s OR project_id LIKE %s
                """
                cursor.execute(query, (f"%{digits}%", f"%{project_id}%"))
                projects = cursor.fetchall()
                
        else:
            print("Fetching all projects")
            query = """
            SELECT project_id, project_name, project_client_id, client_name, product_id, 
                  product_name, managed_by, estimated_cost, completion_days, 
                  release_date, committed_date, description
            FROM projects
            LIMIT 1000
            """
            cursor.execute(query)
            projects = cursor.fetchall()
        
        print(f"Found {len(projects)} projects for report")
        if projects:
            print(f"Project IDs found: {[p['project_id'] for p in projects]}")
        
        # If no projects found, return an error
        if not projects:
            print("No projects found with the given criteria")
            return jsonify({"error": "No projects found with the given criteria"}), 404
        
        # Format dates for display
        formatted_projects = []
        for project in projects:
            formatted_project = {}
            for key, value in project.items():
                if isinstance(value, datetime):
                    formatted_project[key] = value.strftime('%Y-%m-%d')
                else:
                    formatted_project[key] = value
            formatted_projects.append(formatted_project)
        
        # Log download
        log_download(
            report_type='project',
            entity_id=project_id if project_id else None,
            download_format=format.lower(),
            record_count=len(formatted_projects),
            filter_params=filter_params
        )
        
        # Generate and return report
        if format.lower() == 'csv':
            print("Generating CSV report")
            return generate_csv_report(formatted_projects, 'project_report')
        elif format.lower() == 'pdf':
            print("Generating PDF report")
            return generate_pdf_report(formatted_projects, 'Project Report')
        else:
            print(f"Invalid format requested: {format}")
            return jsonify({"error": "Invalid format. Use 'csv' or 'pdf'"}), 400
            
    except Exception as e:
        print(f"Error in download_project_report: {str(e)}")
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()
            print("Database connection closed")

@app.route('/api/download-product-report/<format>', methods=['GET'])
def download_product_report(format):
    product_id = request.args.get('productId', '')
    filter_params = {
        'productId': product_id
    }
    
    print(f"Downloading product report in {format} format with productId: '{product_id}'")
    
    conn = get_db_connection()
    if conn is None:
        print("Database connection failed when downloading product report")
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = conn.cursor(dictionary=True)
        
        if product_id:
            print(f"Fetching specific product with ID: {product_id}")
            query = """
            SELECT product_id, product_name, date_of_product, product_status,
                  product_description, product_technical, product_specification, product_framework
            FROM products
            WHERE product_id = %s
            """
            cursor.execute(query, (product_id,))
        else:
            print("Fetching all products (up to 1000 records)")
            query = """
            SELECT product_id, product_name, date_of_product, product_status,
                  product_description, product_technical, product_specification, product_framework
            FROM products
            LIMIT 1000
            """
            cursor.execute(query)
        
        # Use dictionary cursor to get products
        products = cursor.fetchall()
        print(f"Found {len(products)} products for report")
        if products:
            print(f"Product IDs sample: {[p['product_id'] for p in products[:5]]}")
        
        # If no products found, return an error
        if not products:
            return jsonify({"error": "No products found with the given criteria"}), 404
        
        # Format dates for display
        formatted_products = []
        for product in products:
            formatted_product = {}
            for key, value in product.items():
                if isinstance(value, datetime):
                    formatted_product[key] = value.strftime('%Y-%m-%d')
                else:
                    formatted_product[key] = value
            formatted_products.append(formatted_product)
        
        log_download(
            report_type='product',
            entity_id=product_id if product_id else None,
            download_format=format.lower(),
            record_count=len(formatted_products),
            filter_params=filter_params
        )
        
        if format.lower() == 'csv':
            return generate_csv_report(formatted_products, 'product_report')
        elif format.lower() == 'pdf':
            return generate_pdf_report(formatted_products, 'Product Report')
        else:
            return jsonify({"error": "Invalid format. Use 'csv' or 'pdf'"}), 400
            
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()


def generate_csv_report(data, filename_prefix):
    if not data:
        logger.error("No data to export")
        return jsonify({"error": "No data to export"}), 404
    
    try:
        # Make sure we're using StringIO from io module
        output = StringIO()
        writer = csv.writer(output)
        
        # Get the headers from the first item
        headers = list(data[0].keys())
        writer.writerow(headers)
        
        # Write the data rows
        for row in data:
            writer.writerow([row.get(header, '') for header in headers])
        
        # Create response
        response = make_response(output.getvalue())
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        response.headers["Content-Disposition"] = f"attachment; filename={filename_prefix}_{timestamp}.csv"
        response.headers["Content-Type"] = "text/csv; charset=utf-8"
        
        return response
    except Exception as e:
        logger.error(f"CSV generation error: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({"error": f"Failed to generate CSV: {str(e)}"}), 500
    
# Add these routes to get download statistics
@app.route('/api/download-stats', methods=['GET'])
def get_download_stats():
    """Get statistics about report downloads"""
    connection = get_db_connection()
    if connection is None:
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = connection.cursor(dictionary=True)
        
        # Get overall download count by type and format
        query_overall = """
        SELECT 
            report_type, 
            download_format, 
            COUNT(*) as download_count
        FROM download_logs
        GROUP BY report_type, download_format
        ORDER BY report_type, download_format
        """
        cursor.execute(query_overall)
        overall_stats = cursor.fetchall()
        
        # Get recent downloads (last 30 days)
        query_recent = """
        SELECT 
            log_id,
            report_type,
            entity_id,
            download_format,
            download_date,
            record_count
        FROM download_logs
        WHERE download_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)
        ORDER BY download_date DESC
        LIMIT 100
        """
        cursor.execute(query_recent)
        recent_downloads = cursor.fetchall()
        
        # Format dates for JSON response
        formatted_downloads = []
        for download in recent_downloads:
            formatted_download = {}
            for key, value in download.items():
                if isinstance(value, datetime):
                    formatted_download[key] = value.strftime('%Y-%m-%d %H:%M:%S')
                else:
                    formatted_download[key] = value
            formatted_downloads.append(formatted_download)
        
        return jsonify({
            'overall_stats': overall_stats,
            'recent_downloads': formatted_downloads
        })
        
    except Error as e:
        return jsonify({"error": str(e)}), 500
        
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()

@app.route('/api/download-report/<int:log_id>/repeat', methods=['GET'])
def repeat_download(log_id):
    """Repeat a previous download based on its log ID"""
    connection = get_db_connection()
    if connection is None:
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = connection.cursor(dictionary=True)
        
        # Get the download log entry
        query = "SELECT * FROM download_logs WHERE log_id = %s"
        cursor.execute(query, (log_id,))
        log_entry = cursor.fetchone()
        
        if not log_entry:
            return jsonify({"error": "Download log not found"}), 404
            
        # Parse filter parameters
        filter_params = json.loads(log_entry.get('filter_params', '{}')) if log_entry.get('filter_params') else {}
        
        # Set query parameters for redirection
        query_string = '&'.join([f"{key}={value}" for key, value in filter_params.items() if value])
        
        # Determine which endpoint to call
        report_type = log_entry.get('report_type')
        download_format = log_entry.get('download_format')
        
        if not report_type or not download_format:
            return jsonify({"error": "Invalid log entry data"}), 400
            
        # Redirect to appropriate download endpoint
        redirect_url = f"/api/download-{report_type}-report/{download_format}"
        if query_string:
            redirect_url += f"?{query_string}"
            
        # Return URL for frontend to redirect
        return jsonify({"redirect_url": redirect_url}), 200
        
    except Error as e:
        return jsonify({"error": str(e)}), 500
        
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()
            
# Add these API routes to support the download log admin interface

@app.route('/api/download-logs', methods=['GET'])
def get_download_logs():
    """Get all download logs with optional filtering"""
    # Get filter parameters
    report_type = request.args.get('reportType', '')
    download_format = request.args.get('format', '')
    start_date = request.args.get('startDate', '')
    end_date = request.args.get('endDate', '')
    limit = int(request.args.get('limit', 100))  # Default to 100 records
    
    connection = get_db_connection()
    if connection is None:
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = connection.cursor(dictionary=True)
        
        # Build query with optional filters
        query = "SELECT * FROM download_logs WHERE 1=1"
        params = []
        
        if report_type:
            query += " AND report_type = %s"
            params.append(report_type)
            
        if download_format:
            query += " AND download_format = %s"
            params.append(download_format)
            
        if start_date:
            query += " AND download_date >= %s"
            params.append(start_date)
            
        if end_date:
            query += " AND download_date <= %s"
            params.append(end_date)
            
        query += " ORDER BY download_date DESC LIMIT %s"
        params.append(limit)
        
        cursor.execute(query, params)
        logs = cursor.fetchall()
        
        # Format dates
        formatted_logs = []
        for log in logs:
            formatted_log = {}
            for key, value in log.items():
                if isinstance(value, datetime):
                    formatted_log[key] = value.strftime('%Y-%m-%d %H:%M:%S')
                else:
                    formatted_log[key] = value
            formatted_logs.append(formatted_log)
            
        return jsonify(formatted_logs)
        
    except Error as e:
        return jsonify({"error": str(e)}), 500
        
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()

@app.route('/api/download-stats/summary', methods=['GET'])
def get_download_summary():
    """Get summary statistics about downloads"""
    connection = get_db_connection()
    if connection is None:
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = connection.cursor(dictionary=True)
        
        # Get download count by report type
        cursor.execute("""
            SELECT report_type, COUNT(*) as count 
            FROM download_logs 
            GROUP BY report_type
        """)
        by_report_type = cursor.fetchall()
        
        # Get download count by format
        cursor.execute("""
            SELECT download_format, COUNT(*) as count 
            FROM download_logs 
            GROUP BY download_format
        """)
        by_format = cursor.fetchall()
        
        # Get daily downloads for the last 30 days
        cursor.execute("""
            SELECT 
                DATE(download_date) as date, 
                COUNT(*) as count 
            FROM download_logs 
            WHERE download_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
            GROUP BY DATE(download_date)
            ORDER BY date
        """)
        daily_counts = cursor.fetchall()
        
        # Format dates in daily counts
        formatted_daily = []
        for item in daily_counts:
            formatted_item = {}
            for key, value in item.items():
                if isinstance(value, date):
                    formatted_item[key] = value.strftime('%Y-%m-%d')
                else:
                    formatted_item[key] = value
            formatted_daily.append(formatted_item)
        
        # Get top downloaded entities
        cursor.execute("""
            SELECT 
                report_type,
                entity_id,
                COUNT(*) as download_count
            FROM download_logs
            WHERE entity_id IS NOT NULL
            GROUP BY report_type, entity_id
            ORDER BY download_count DESC
            LIMIT 10
        """)
        top_entities = cursor.fetchall()
        
        return jsonify({
            'by_report_type': by_report_type,
            'by_format': by_format,
            'daily_counts': formatted_daily,
            'top_entities': top_entities
        })
        
    except Error as e:
        return jsonify({"error": str(e)}), 500
        
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()

@app.route('/api/download-logs/<int:log_id>', methods=['DELETE'])
def delete_download_log(log_id):
    """Delete a specific download log entry"""
    connection = get_db_connection()
    if connection is None:
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = connection.cursor()
        
        # Delete the log entry
        cursor.execute("DELETE FROM download_logs WHERE log_id = %s", (log_id,))
        connection.commit()
        
        if cursor.rowcount == 0:
            return jsonify({"error": "Log entry not found"}), 404
            
        return jsonify({"message": "Log entry deleted successfully"}), 200
        
    except Error as e:
        return jsonify({"error": str(e)}), 500
        
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()

@app.route('/api/download-logs/clear', methods=['POST'])
def clear_download_logs():
    """Clear all download logs older than a specified date"""
    data = request.get_json()
    if not data or 'olderThan' not in data:
        return jsonify({"error": "Missing required parameter 'olderThan'"}), 400
        
    older_than = data.get('olderThan')  # Should be in YYYY-MM-DD format
    
    connection = get_db_connection()
    if connection is None:
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = connection.cursor()
        
        # Clear log entries older than the specified date
        cursor.execute("DELETE FROM download_logs WHERE download_date < %s", (older_than,))
        connection.commit()
        
        return jsonify({
            "message": "Log entries cleared successfully", 
            "deletedCount": cursor.rowcount
        }), 200
        
    except Error as e:
        return jsonify({"error": str(e)}), 500
        
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()
            
@app.route('/api/project-download/<project_id>', methods=['GET'])
def download_project_by_id(project_id):
    format = request.args.get('format', 'csv')
    print(f"Project download requested for project_id: {project_id} in format: {format}")
    
    # Pass the project_id directly for better identification in the reports
    return redirect(url_for('download_project_report', format=format, projectId=project_id))




@app.route('/api/test-csv', methods=['GET'])
def test_csv():
    # Sample data for testing
    data = [
        {"Project ID": "PRO922", "Project Name": "Sample Project", "Status": "Active"},
        {"Project ID": "PRO923", "Project Name": "Another Project", "Status": "Completed"}
    ]
    return generate_csv_report(data, "project_report")

@app.route('/api/<data_type>-download/<item_id>', methods=['GET'])
def download_data(data_type, item_id):
    try:
        format_type = request.args.get("format", "pdf").lower()
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)

        # Choose table and column
        if data_type == "product":
            table, column = "products", "product_id"
        elif data_type == "client":
            table, column = "clients", "client_id"
        elif data_type == "project":
            table, column = "projects", "project_id"
        else:
            return jsonify({"error": "Invalid data type"}), 400

        query = f"SELECT * FROM {table} WHERE {column} = %s"
        cursor.execute(query, (item_id,))
        result = cursor.fetchall()
        cursor.close()
        conn.close()

        if not result:
            return jsonify({"error": f"No {data_type} found with ID {item_id}"}), 404

        # Convert result to a list of dictionaries with formatted dates
        data = []
        for row in result:
            # Format dates if present
            formatted_row = {}
            for key, value in row.items():
                if isinstance(value, datetime):
                    formatted_row[key] = value.strftime('%Y-%m-%d')
                else:
                    formatted_row[key] = value
            data.append(formatted_row)

        # Log the download for statistics
        log_download(data_type, item_id, format_type, len(data))

        if format_type == "csv":
            # Use the improved CSV generation
            return generate_csv_report(data, f"{data_type}_{item_id}")
        elif format_type == "pdf":
            # Use the improved PDF generation
            return generate_pdf_report(data, f"{data_type.capitalize()} Report")
        else:
            return jsonify({"error": "Invalid format type. Use 'csv' or 'pdf'"}), 400
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    
# ================== TASK ROUTES ==================

# Get all tasks
@app.route('/tasks', methods=['GET'])
def get_all_tasks():
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"success": False, "error": "Database connection failed", "tasks": []}), 500
            
        cursor = conn.cursor(dictionary=True)
        
        try:
            cursor.execute("""
                SELECT 
                    t.task_id as taskId, 
                    t.task_name as taskName, 
                    t.task_description as taskDescription,
                    t.project_id as projectId,
                    t.project_name as projectName,
                    t.product_name as productName,
                    t.client_name as clientName,
                    t.initiative_date as initiativeDate,
                    t.target_completion_date as targetCompletionDate,
                    t.actual_completion_date as actualCompletionDate,
                    t.status
                FROM tasks t
                LEFT JOIN projects p ON t.project_id = p.project_id
            """)
            
            tasks = cursor.fetchall()
            
            # Format date fields
            for task in tasks:
                format_dates(task)
            
            return jsonify({"success": True, "tasks": tasks})
        
        except Exception as e:
            logger.error(f"Query error in get_all_tasks: {e}")
            return jsonify({"success": False, "error": str(e), "tasks": []}), 500
        
        finally:
            cursor.close()
            conn.close()
            
    except Error as e:
        logger.error(f"Database error in get_all_tasks: {e}")
        return jsonify({"success": False, "error": str(e), "tasks": []}), 500
    except Exception as e:
        logger.error(f"Unexpected error in get_all_tasks: {e}")
        return jsonify({"success": False, "error": str(e), "tasks": []}), 500

# Get a specific task
@app.route('/tasks/<task_id>', methods=['GET'])
def get_task(task_id):
    try:
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        
        cursor.execute("""
            SELECT 
                t.task_id as taskId, 
                t.task_name as taskName, 
                t.task_description as taskDescription,
                t.project_id as projectId,
                t.project_name as projectName,
                t.product_name as productName,
                t.client_name as clientName,
                t.initiative_date as initiativeDate,
                t.target_completion_date as targetCompletionDate,
                t.actual_completion_date as actualCompletionDate,
                t.status
            FROM tasks t
            LEFT JOIN projects p ON t.project_id = p.project_id
            WHERE t.task_id = %s
        """, (task_id,))
        
        task = cursor.fetchone()
        
        cursor.close()
        conn.close()
        
        if task:
            # Format date fields
            format_dates(task)
            return jsonify(task)
        else:
            return jsonify({"error": "Task not found"}), 404
            
    except Error as e:
        return jsonify({"error": str(e)}), 500

@app.route('/tasks', methods=['POST'])
def create_task():
    """API endpoint to create a new task in the database"""
    try:
        # Get the task data from the request
        task_data = request.json
        logger.info(f"Received task data: {task_data}")
        
        # Check if all required fields are present
        required_fields = ['taskId', 'taskName', 'taskDescription', 'projectId', 
                          'initiativeDate', 'targetCompletionDate']
        
        for field in required_fields:
            if field not in task_data:
                logger.error(f"Missing required field: {field}")
                return jsonify({"error": f"Missing required field: {field}"}), 400
        
        # Connect to the database
        connection = get_db_connection()
        if not connection:
            return jsonify({"error": "Database connection failed"}), 500
        
        cursor = connection.cursor()
        
        # Verify if the project exists
        cursor.execute("SELECT project_id, project_name FROM projects WHERE project_id = %s", 
                      (task_data['projectId'],))
        project = cursor.fetchone()
        
        if not project:
            logger.warning(f"Project ID {task_data['projectId']} not found")
            # For development purposes, let's insert anyway
            # In production, you might want to return an error
            # return jsonify({"error": "Project ID not found"}), 404
        
        # Insert task into database - map camelCase from frontend to snake_case in database
        insert_query = """
        INSERT INTO tasks (
            task_id, task_name, task_description, project_id, project_name,
            product_name, client_name, initiative_date,
            target_completion_date, status
        ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        values = (
            task_data['taskId'],
            task_data['taskName'],
            task_data['taskDescription'],
            task_data['projectId'],
            task_data.get('projectName', None),
            task_data.get('productName', None),
            task_data.get('clientName', None),
            task_data['initiativeDate'],
            task_data['targetCompletionDate'],
            'Not Started'  # Default status
        )
        
        cursor.execute(insert_query, values)
        connection.commit()
        
        logger.info(f"Task {task_data['taskId']} created successfully")
        
        # Close database connection
        cursor.close()
        connection.close()
        
        return jsonify({
            "success": True,
            "message": "Task created successfully",
            "taskId": task_data['taskId']
        }), 201
        
    except Error as e:
        logger.error(f"Database error: {e}")
        return jsonify({"error": f"Database error: {str(e)}"}), 500
    except Exception as e:
        logger.error(f"Server error: {e}")
        return jsonify({"error": f"Server error: {str(e)}"}), 500

# Update a task
@app.route('/tasks/<task_id>', methods=['PUT'])
def update_task(task_id):
    data = request.get_json()
    
    # Validate the task data
    errors = validate_task_data(data)
    if errors:
        return jsonify({"error": "Validation failed", "details": errors}), 400
    
    try:
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        
        # Check if task exists
        cursor.execute("SELECT task_id FROM tasks WHERE task_id = %s", (task_id,))
        if not cursor.fetchone():
            cursor.close()
            conn.close()
            return jsonify({"error": "Task not found"}), 404
        
        # Check if project exists
        cursor.execute("SELECT * FROM projects WHERE project_id = %s", (data['projectId'],))
        project = cursor.fetchone()
        
        if not project:
            cursor.close()
            conn.close()
            return jsonify({"error": "Project not found"}), 404
        
        # Update the task
        update_query = """
            UPDATE tasks SET
                task_name = %s,
                task_description = %s,
                project_id = %s,
                project_name = %s,
                product_name = %s,
                client_name = %s,
                initiative_date = %s,
                target_completion_date = %s
            WHERE task_id = %s
        """
        
        cursor.execute(update_query, (
            data['taskName'],
            data['taskDescription'],
            data['projectId'],
            data.get('projectName', project.get('project_name')),
            data.get('productName', project.get('product_name')),
            data.get('clientName', project.get('client_name')),
            data['initiativeDate'],
            data['targetCompletionDate'],
            task_id
        ))
        
        cursor.close()
        conn.close()
        
        return jsonify({"message": "Task updated successfully"})
        
    except Error as e:
        return jsonify({"error": str(e)}), 500

# Delete a task
@app.route('/tasks/<task_id>', methods=['DELETE'])
def delete_task(task_id):
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Check if task exists
        cursor.execute("SELECT task_id FROM tasks WHERE task_id = %s", (task_id,))
        if not cursor.fetchone():
            cursor.close()
            conn.close()
            return jsonify({"error": "Task not found"}), 404
        
        # Delete the task
        cursor.execute("DELETE FROM tasks WHERE task_id = %s", (task_id,))
        
        cursor.close()
        conn.close()
        
        return jsonify({"message": "Task deleted successfully"})
        
    except Error as e:
        return jsonify({"error": str(e)}), 500

# Update task status
@app.route('/update_task_status', methods=['POST'])
def update_task_status():
    data = request.get_json()
    print(f"Received data: {data}")  # Log the incoming data to inspect

    # Check if data is None
    if not data:
        return jsonify({'success': False, 'message': 'No data provided'}), 400

    task_id = data.get('taskId')
    task_status = data.get('taskStatus')
    reason = data.get('reason')
    allocate_by = data.get('allocateBy')
    employee_id = data.get('employeeId')
    assigned_date = data.get('assignedDate')
    target_date = data.get('targetDate')

    # Validate required fields
    if not task_id or not task_status or not reason:
        return jsonify({'success': False, 'message': 'Missing required fields'}), 400

    # Parse dates if provided
    try:
        # Handle DD-MM-YYYY format
        if assigned_date:
            try:
                # Try to parse as DD-MM-YYYY
                day, month, year = assigned_date.split('-')
                assigned_date = f"{year}-{month}-{day}"  # Convert to YYYY-MM-DD for MySQL
            except ValueError:
                # If not in DD-MM-YYYY format, try to use as is (might be already in ISO format)
                pass
                
        if target_date:
            try:
                # Try to parse as DD-MM-YYYY
                day, month, year = target_date.split('-')
                target_date = f"{year}-{month}-{day}"  # Convert to YYYY-MM-DD for MySQL
            except ValueError:
                # If not in DD-MM-YYYY format, try to use as is (might be already in ISO format)
                pass
    except Exception as e:
        print(f"Date parsing error: {e}")
        return jsonify({'success': False, 'message': f'Invalid datetime format: {str(e)}'}), 400

    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({'success': False, 'message': 'Database connection failed'}), 500
            
        cursor = connection.cursor()

        # Get task_name from tasks table, ensure task_name exists
        cursor.execute("SELECT task_name FROM tasks WHERE task_id = %s", (task_id,))
        row = cursor.fetchone()

        if not row or not row[0]:
            task_name = "Unknown Task"  # Set default value if task_name is missing
        else:
            task_name = row[0]

        # Always insert a new record for task status updates, regardless of existing entries
        query = """
            INSERT INTO task_update (
                task_id, task_name, task_status, reason,
                allocate_by, employee_id, assigned_date, target_date
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        cursor.execute(query, (
            task_id, task_name, task_status, reason,
            allocate_by, employee_id, assigned_date, target_date
        ))

        # Commit changes to the database
        connection.commit()
        
        cursor.close()
        connection.close()

        return jsonify({'success': True, 'message': 'Task status saved'}), 200

    except mysql.connector.Error as e:
        print(f"MySQL error: {e}")
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection.is_connected():
            connection.close()
        return jsonify({'success': False, 'message': f"Database error: {str(e)}"}), 500
    except Exception as e:
        print(f"General error: {e}")
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection.is_connected():
            connection.close()
        return jsonify({'success': False, 'message': f"An error occurred: {str(e)}"}), 500

# Get tasks for a specific project
@app.route('/projects/<project_id>/tasks', methods=['GET'])
def get_project_tasks(project_id):
    try:
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        
        # Check if project exists
        cursor.execute("SELECT project_id FROM projects WHERE project_id = %s", (project_id,))
        if not cursor.fetchone():
            cursor.close()
            conn.close()
            return jsonify({"error": "Project not found"}), 404
        
        cursor.execute("""
            SELECT 
                task_id as taskId, 
                task_name as taskName, 
                task_description as taskDescription,
                project_name as projectName,
                initiative_date as initiativeDate,
                target_completion_date as targetCompletionDate,
                actual_completion_date as actualCompletionDate,
                status
            FROM tasks
            WHERE project_id = %s
        """, (project_id,))
        
        tasks = cursor.fetchall()
        
        # Format date fields
        for task in tasks:
            format_dates(task)
        
        cursor.close()
        conn.close()
        
        return jsonify(tasks)
        
    except Error as e:
        return jsonify({"error": str(e)}), 500
    
    
    
    
@app.route('/api/task-allocation', methods=['GET'])
def get_task_allocations():
    """Get all task allocations with optional filtering"""
    try:
        # Extract query parameters for filtering
        employee_id = request.args.get('employee_id')
        project_name = request.args.get('project_name')
        product_name = request.args.get('product_name')
        client_name = request.args.get('client_name')
        
        conn = get_db_connection()
        if not conn:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor(dictionary=True)
        
        # Base query
        query = "SELECT * FROM task_allocation WHERE 1=1"
        params = []
        
        # Add filters if provided
        if employee_id:
            query += " AND employee_id = %s"
            params.append(employee_id)
        
        if project_name:
            query += " AND project_name = %s"
            params.append(project_name)
            
        if product_name:
            query += " AND product_name = %s"
            params.append(product_name)
            
        if client_name:
            query += " AND client_name = %s"
            params.append(client_name)
        
        # Add ordering
        query += " ORDER BY created_at DESC"
        
        cursor.execute(query, params)
        tasks = cursor.fetchall()
        
        # Convert dates to string format for JSON serialization
        for task in tasks:
            for key, value in task.items():
                if isinstance(value, datetime):
                    task[key] = value.isoformat()
        
        cursor.close()
        conn.close()
        
        return jsonify(tasks), 200
        
    except Error as e:
        return jsonify({'error': f'Database error: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'error': f'Server error: {str(e)}'}), 500

@app.route('/get_task_allocation/<task_id>', methods=['GET'])
def get_task_allocation(task_id):
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({'success': False, 'error': 'Database connection failed'}), 500

        cursor = connection.cursor(dictionary=True)

        # Fetch from task_allocation
        cursor.execute("""
            SELECT task_name, employee_name, employee_id, assigned_date, target_date
            FROM task_allocation
            WHERE task_id = %s
        """, (task_id,))
        task = cursor.fetchone()

        if not task:
            return jsonify({'success': False, 'message': 'Task not found'}), 404

        # Convert date fields to strings if necessary
        task['assigned_date'] = task['assigned_date'].strftime('%Y-%m-%d') if task['assigned_date'] else None
        task['target_date'] = task['target_date'].strftime('%Y-%m-%d') if task['target_date'] else None

        return jsonify({'success': True, 'taskDetails': task})
    
    except Exception as e:
        print(f"Error retrieving task allocation: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500
    
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'connection' in locals() and connection.is_connected():
            connection.close()

@app.route('/api/task-allocation/<task_id>', methods=['PUT'])
def update_task_allocation(task_id):
    """Update an existing task allocation"""
    try:
        data = request.json
        
        conn = get_db_connection()
        if not conn:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor()
        
        # First, check if the task exists
        cursor.execute("SELECT 1 FROM task_allocation WHERE task_id = %s", (task_id,))
        if not cursor.fetchone():
            cursor.close()
            conn.close()
            return jsonify({'error': 'Task allocation not found'}), 404
        
        # Prepare update query
        query = "UPDATE task_allocation SET "
        params = []
        
        # Add fields to update
        fields = [
            'task_name', 'project_name', 'product_name', 'client_name',
            'initiative_date', 'target_completion_date', 'employee_id',
            'assigned_date', 'target_date', 'remarks', 'employee_name', 'role_name'
        ]
        
        update_parts = []
        
        for field in fields:
            if field in data:
                # Format dates
                if field.endswith('_date') and data[field]:
                    try:
                        data[field] = datetime.strptime(data[field], '%Y-%m-%d').date()
                    except ValueError:
                        return jsonify({'error': f'Invalid date format for {field}. Use YYYY-MM-DD'}), 400
                
                update_parts.append(f"{field} = %s")
                params.append(data[field])
        
        if not update_parts:
            return jsonify({'message': 'No fields to update'}), 200
        
        query += ", ".join(update_parts)
        query += " WHERE task_id = %s"
        params.append(task_id)
        
        cursor.execute(query, params)
        conn.commit()
        
        cursor.close()
        conn.close()
        
        return jsonify({'message': 'Task allocation updated successfully'}), 200
        
    except Error as e:
        return jsonify({'error': f'Database error: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'error': f'Server error: {str(e)}'}), 500

@app.route('/api/task-allocation/<task_id>', methods=['DELETE'])
def delete_task_allocation(task_id):
    """Delete a task allocation"""
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor()
        
        # Check if task exists
        cursor.execute("SELECT 1 FROM task_allocation WHERE task_id = %s", (task_id,))
        if not cursor.fetchone():
            cursor.close()
            conn.close()
            return jsonify({'error': 'Task allocation not found'}), 404
        
        # Delete the task
        cursor.execute("DELETE FROM task_allocation WHERE task_id = %s", (task_id,))
        conn.commit()
        
        cursor.close()
        conn.close()
        
        return jsonify({'message': 'Task allocation deleted successfully'}), 200
        
    except Error as e:
        return jsonify({'error': f'Database error: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'error': f'Server error: {str(e)}'}), 500
    
    

# Helper function to handle date formatting
def format_date_for_db(date_str):
    """Process date in DD-MM-YYYY format and return as is for MySQL"""
    if not date_str:
        return None
    try:
        # Validate the date format (DD-MM-YYYY)
        day, month, year = date_str.split('-')
        # Return the date in the same format (DD-MM-YYYY) as MySQL is configured to accept it
        return date_str
    except Exception as e:
        print(f"Error processing date format: {e}")
        return None

@app.route('/allocate_task', methods=['POST'])
def allocate_task():
    """Handle task allocation to an employee"""
    try:
        # Get request data
        data = request.json
        print(f"Received allocation request: {data}")
        
        # Check required fields
        required_fields = [
            'taskId', 'employeeId', 'employeeName', 'roleName',
            'assignedDate', 'targetDate', 'reportingPersonId'
        ]
        
        for field in required_fields:
            if not data.get(field):
                return jsonify({'error': f'Missing required field: {field}'}), 400
        
        # Connect to DB
        connection = get_db_connection()
        if not connection:
            return jsonify({'error': 'Database connection failed'}), 500
        
        cursor = connection.cursor()

        task_id = data['taskId']

        # Check if task already allocated
        cursor.execute("SELECT * FROM task_allocation WHERE task_id = %s", (task_id,))
        existing_task = cursor.fetchone()

        # Prepare dates
        assigned_date = sanitize_date_field(data['assignedDate'])
        target_date = sanitize_date_field(data['targetDate'])
        initiative_date = sanitize_date_field(data.get('initiativeDate'))
        target_completion_date = sanitize_date_field(data.get('targetCompletionDate'))

        # Get task details if needed
        cursor.execute("SELECT * FROM tasks WHERE task_id = %s", (task_id,))
        task_details = cursor.fetchone()

        # Use defaults if necessary
        task_name = data.get('taskName', "Unknown Task")
        project_name = data.get('projectName', "Unknown Project")
        product_name = data.get('productName', "Unknown Product")
        client_name = data.get('clientName', "Unknown Client")

        if task_details:
            task_name = task_details[1] or task_name
            project_name = task_details[3] or project_name
            product_name = task_details[4] or product_name
            client_name = task_details[5] or client_name
            initiative_date = sanitize_date_field(task_details[6]) or initiative_date
            target_completion_date = sanitize_date_field(task_details[7]) or target_completion_date

        # Update or Insert
        if existing_task:
            update_query = """
                UPDATE task_allocation 
                SET employee_id = %s,
                    employee_name = %s,
                    role_name = %s,
                    reporting_person_id = %s,
                    assigned_date = %s,
                    target_date = %s,
                    remarks = %s,
                    updated_at = CURRENT_TIMESTAMP
                WHERE task_id = %s
            """
            cursor.execute(update_query, (
                data['employeeId'],
                data['employeeName'],
                data['roleName'],
                data['reportingPersonId'],
                assigned_date,
                target_date,
                data.get('remarks', ''),
                task_id
            ))
            action = 'updated'
        else:
            insert_query = """
                INSERT INTO task_allocation (
                    task_id, task_name, project_name, product_name, client_name,
                    initiative_date, target_completion_date,
                    employee_id, employee_name, role_name,
                    reporting_person_id, assigned_date, target_date, remarks
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            cursor.execute(insert_query, (
                task_id,
                task_name,
                project_name,
                product_name,
                client_name,
                initiative_date,
                target_completion_date,
                data['employeeId'],
                data['employeeName'],
                data['roleName'],
                data['reportingPersonId'],
                assigned_date,
                target_date,
                data.get('remarks', '')
            ))
            action = 'created'

        connection.commit()
        return jsonify({
            'success': True,
            'message': f'Task allocation {action} successfully',
            'taskId': task_id,
            'employeeId': data['employeeId']
        })

    except Exception as e:
        print(f"Error processing request: {e}")
        return jsonify({'error': f'Error processing request: {str(e)}'}), 500
    finally:
        if 'connection' in locals() and connection.is_connected():
            cursor.close()
            connection.close()
            
            

def generate_pdf_report(data, report_title):
    if not data:
        logger.error("No data to export")
        return jsonify({"error": "No data to export"}), 404
    
    try:
        # Create a modern, professional PDF report with refined styling
        buffer = BytesIO()
        
        # Use landscape for wider tables, optimized margins
        doc = SimpleDocTemplate(
            buffer, 
            pagesize=landscape(A4),
            leftMargin=25,    # Balanced margins
            rightMargin=25,   # Balanced margins
            topMargin=80,     # Space for header
            bottomMargin=50
        )
        
        # Corporate color palette (blue tones)
        corporate_dark_blue = colors.HexColor("#003366")  # Deep blue for headers
        corporate_light_blue = colors.HexColor("#E6EFF6")  # Light blue for alternate rows
        corporate_accent = colors.HexColor("#4F81BD")  # Medium blue for accents
        
        # Document elements list
        elements = []
        
        # Add space at top to avoid header overlap
        elements.append(Spacer(1, 15))
        
        # Add report summary section
        if data:
            # Summary data
            records_count = len(data)
            current_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # Create summary title
            title_style = ParagraphStyle(
                name='SectionTitle',
                fontName='Helvetica-Bold',
                fontSize=12,
                textColor=corporate_dark_blue,
                alignment=1,  # Center alignment
                spaceAfter=10
            )
            elements.append(Paragraph('Report Summary', title_style))
            
            # Create summary table with clean styling
            summary_data = [
                ["Records", str(records_count)],
                ["Report Type", report_title],
                ["Generated At", current_date]
            ]
            
            # Summary table styling
            summary_table = Table(summary_data, colWidths=[120, 200])
            summary_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, -1), corporate_light_blue),
                ('BACKGROUND', (1, 0), (1, -1), colors.white),
                ('TEXTCOLOR', (0, 0), (0, -1), corporate_dark_blue),
                ('TEXTCOLOR', (1, 0), (1, -1), colors.black),
                ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                ('ALIGN', (1, 0), (1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (0, -1), 9),
                ('FONTSIZE', (1, 0), (1, -1), 9),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('INNERGRID', (0, 0), (-1, -1), 0.25, colors.lightgrey),
                ('BOX', (0, 0), (-1, -1), 0.25, corporate_accent),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ]))
            
            # Create container for centered summary table
            summary_container = Table([[summary_table]], colWidths=[doc.width])
            summary_container.setStyle(TableStyle([
                ('ALIGN', (0, 0), (0, 0), 'CENTER'),
                ('VALIGN', (0, 0), (0, 0), 'MIDDLE'),
            ]))
            elements.append(summary_container)
            elements.append(Spacer(1, 20))
            
            # Create data table with modern styling
            headers = list(data[0].keys())
            
            # Enhanced column mapping for better readability - map DB column names to display names
            header_mapping = {
                # Project report mappings
                'project_id': 'Project ID',
                'project_name': 'Project Name',
                'project_client_id': 'Client ID',
                'managed_by': 'Managed By',
                'estimated_cost': 'Est. Cost',
                'completion_days': 'Compl Days',
                'release_date': 'Release Date',
                'committed_date': 'Commit Date',
                'description': 'Description',
                
                # Product report mappings
                'product_id': 'Product ID',
                'product_name': 'Product Name',
                'date_of_product': 'Date',
                'product_status': 'Status',
                'product_description': 'Description',
                'product_technical': 'Technical',
                'product_specification': 'Specification',
                'product_framework': 'Framework'
            }
            
            # Generate display headers with proper capitalization and spacing
            display_headers = []
            header_style = ParagraphStyle(
                'HeaderStyle',
                fontName='Helvetica-Bold',
                fontSize=9.5,
                textColor=colors.white,
                alignment=1,  # Center alignment
                spaceAfter=0,
                spaceBefore=0,
                leading=11
            )

            for h in headers:
                h_lower = h.lower()
                if h_lower in header_mapping:
                    display_headers.append(Paragraph(header_mapping[h_lower], header_style))
                else:
                    # Clean up any headers not in our mapping
                    text = ' '.join(word.capitalize() for word in h.replace('_', ' ').split())
                    display_headers.append(Paragraph(text, header_style))
            
            # Table data with display headers
            table_data = [display_headers]
            
            # Format the data rows
            for row in data:
                table_row = []
                for header in headers:
                    value = row.get(header, '')
                    # Right-align numeric fields
                    if isinstance(value, (int, float)):
                        cell_style = ParagraphStyle(
                            'RightAligned',
                            parent=None,
                            alignment=2,  # Right alignment
                            fontSize=9
                        )
                        if isinstance(value, int):
                            cell_text = "{:,}".format(value)
                        else:
                            cell_text = "{:,.2f}".format(value)
                        table_row.append(Paragraph(cell_text, cell_style))
                    elif header.lower().endswith('date') and value:
                        # Center align dates
                        cell_style = ParagraphStyle(
                            'CenterAligned',
                            parent=None,
                            alignment=1,  # Center alignment
                            fontSize=9
                        )
                        table_row.append(Paragraph(str(value), cell_style))
                    else:
                        # Left-align text
                        cell_style = ParagraphStyle(
                            'LeftAligned',
                            parent=None,
                            alignment=0,  # Left alignment
                            fontSize=9
                        )
                        table_row.append(Paragraph(str(value), cell_style))
                table_data.append(table_row)
            
            # Optimized column widths - try to make it fit nicely
            col_widths = []
            page_width = doc.width
            
            # Determine number of columns to calculate proportional widths
            num_columns = len(headers)
            default_width = page_width / num_columns
            
            # Special case handling for certain column types
            for i, header in enumerate(headers):
                header_lower = header.lower()
                if header_lower.endswith('_id'):
                    col_widths.append(min(default_width * 0.8, page_width * 0.08))  # IDs are generally short
                elif header_lower.endswith('_name'):
                    col_widths.append(min(default_width * 1.3, page_width * 0.15))  # Names may be longer
                elif header_lower.endswith('_date'):
                    col_widths.append(min(default_width * 0.9, page_width * 0.09))  # Dates have fixed width
                elif header_lower.endswith('description'):
                    col_widths.append(min(default_width * 1.5, page_width * 0.18))  # Descriptions need more space
                elif header_lower in ['estimated_cost', 'completion_days']:
                    col_widths.append(min(default_width * 0.7, page_width * 0.07))  # Numbers can be smaller
                else:
                    col_widths.append(default_width)  # Default column width
            
            # Create data table
            table = Table(
                table_data,
                colWidths=col_widths,
                repeatRows=1,  # Repeat header row on each page
                hAlign='CENTER'
            )
            
            # Professional table styling
            table_style = [
                # Header row styling
                ('BACKGROUND', (0, 0), (-1, 0), corporate_dark_blue),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('VALIGN', (0, 0), (-1, 0), 'MIDDLE'),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
                ('TOPPADDING', (0, 0), (-1, 0), 8),
                ('LEFTPADDING', (0, 0), (-1, -1), 4),
                ('RIGHTPADDING', (0, 0), (-1, -1), 4),
                
                # Grid styling
                ('GRID', (0, 0), (-1, -1), 0.5, colors.lightgrey),
                ('BOX', (0, 0), (-1, -1), 1, corporate_dark_blue),
                ('LINEBELOW', (0, 0), (-1, 0), 1.5, corporate_dark_blue),
                
                # Vertical alignment for data rows
                ('VALIGN', (0, 1), (-1, -1), 'MIDDLE'),
                
                # Row height
                ('BOTTOMPADDING', (0, 1), (-1, -1), 6),
                ('TOPPADDING', (0, 1), (-1, -1), 6),
            ]
            
            # Zebra striping for data rows
            for i in range(1, len(table_data)):
                if i % 2 == 0:
                    table_style.append(('BACKGROUND', (0, i), (-1, i), corporate_light_blue))
                else:
                    table_style.append(('BACKGROUND', (0, i), (-1, i), colors.white))
            
            # Apply style to table
            table.setStyle(TableStyle(table_style))
            
            # Add data table to document
            elements.append(table)
            
            # Add note at bottom
            note_style = ParagraphStyle(
                name='Note',
                fontSize=8,
                textColor=colors.gray,
                alignment=1,  # Center alignment
                spaceBefore=15
            )
            elements.append(Paragraph(f"Data accurate as of {datetime.now().strftime('%Y-%m-%d %H:%M')}", note_style))
        
        else:
            # No data message
            elements.append(Paragraph("No data available for this report", 
                ParagraphStyle(
                    name='NoData',
                    fontSize=12,
                    alignment=1,
                    spaceBefore=30,
                    spaceAfter=30,
                    textColor=colors.gray
                )
            ))
        
        # Define header and footer function
        def header_footer(canvas, doc):
            # Save canvas state
            canvas.saveState()
            
            # Get page dimensions
            width, height = landscape(A4)
            
            # Draw top header bar
            canvas.setFillColor(corporate_dark_blue)
            canvas.rect(0, height - 60, width, 60, fill=1, stroke=0)
            
            # Add logo/title text
            canvas.setFillColor(colors.white)
            canvas.setFont("Helvetica-Bold", 22)
            canvas.drawString(doc.leftMargin, height - 35, "LCODE - INFINITE POSSIBILITIES")
            
            # Add report title
            canvas.setFont("Helvetica-Bold", 16)
            canvas.drawRightString(width - doc.rightMargin, height - 30, report_title)
            
            # Add timestamp
            canvas.setFont("Helvetica", 10)
            canvas.drawRightString(width - doc.rightMargin, height - 45, 
                               f"Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
            # Add footer
            canvas.setStrokeColor(corporate_dark_blue)
            canvas.setLineWidth(1)
            canvas.line(doc.leftMargin, 40, width - doc.rightMargin, 40)
            
            # Footer text
            canvas.setFont("Helvetica-Bold", 9)
            canvas.setFillColor(corporate_dark_blue)
            canvas.drawString(doc.leftMargin, 25, "LCODE")
            
            # Page number
            canvas.drawRightString(width - doc.rightMargin, 25, f"Page {canvas.getPageNumber()}")
            
            # Center text
            canvas.setFillColor(colors.gray)
            canvas.setFont("Helvetica", 8)
            canvas.drawCentredString(width/2, 25, f"Powered by LCODE â€¢ {datetime.now().strftime('%Y-%m-%d')}")
            
            # Restore canvas state
            canvas.restoreState()
        
        # Build PDF with header/footer
        doc.build(elements, onFirstPage=header_footer, onLaterPages=header_footer)
        
        # Prepare response
        buffer.seek(0)
        response = make_response(buffer.getvalue())
        response.headers['Content-Type'] = 'application/pdf'
        response.headers['Content-Disposition'] = f'attachment; filename="{report_title.replace(" ", "_")}.pdf"'
        response.headers['Access-Control-Allow-Origin'] = '*'
        
        return response
        
    except Exception as e:
        logger.error(f"PDF generation error: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({"error": f"Failed to generate PDF: {str(e)}"}), 500

@app.route('/api/download-client-report/<format>', methods=['GET'])
def download_client_report(format):
    client_id = request.args.get('clientId', '')
    filter_params = {
        'clientId': client_id
    }
    
    print(f"Downloading client report in {format} format with clientId: '{client_id}'")
    
    conn = get_db_connection()
    if conn is None:
        print("Database connection failed when downloading client report")
        return jsonify({"error": "Database connection failed"}), 500
    
    try:
        cursor = conn.cursor(dictionary=True)
        
        if client_id:
            print(f"Fetching specific client with ID: {client_id}")
            query = """
            SELECT client_id, client_name, client_description, client_address, 
                  communication_email, contact_name, contact_designation,
                  contact_mobile, contact_email, reporting_to
            FROM clients
            WHERE client_id = %s
            """
            cursor.execute(query, (client_id,))
        else:
            print("Fetching all clients (up to 1000 records)")
            query = """
            SELECT client_id, client_name, client_description, client_address, 
                  communication_email, contact_name, contact_designation,
                  contact_mobile, contact_email, reporting_to
            FROM clients
            LIMIT 1000
            """
            cursor.execute(query)
        
        # Use dictionary cursor to get clients
        clients = cursor.fetchall()
        
        # If no clients found, return an error
        if not clients:
            return jsonify({"error": "No clients found with the given criteria"}), 404
        
        # Format dates for display
        formatted_clients = []
        for client in clients:
            formatted_client = {}
            for key, value in client.items():
                if isinstance(value, datetime):
                    formatted_client[key] = value.strftime('%Y-%m-%d')
                else:
                    formatted_client[key] = value
            formatted_clients.append(formatted_client)
        
        log_download(
            report_type='client',
            entity_id=client_id if client_id else None,
            download_format=format.lower(),
            record_count=len(formatted_clients),
            filter_params=filter_params
        )
        
        if format.lower() == 'csv':
            return generate_csv_report(formatted_clients, 'client_report')
        elif format.lower() == 'pdf':
            return generate_pdf_report(formatted_clients, 'Client Report')
        else:
            return jsonify({"error": "Invalid format. Use 'csv' or 'pdf'"}), 400
            
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()

@app.route('/get_task_status_history/<task_id>', methods=['GET'])
def get_task_status_history(task_id):
    """Get status history for a specific task"""
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({'success': False, 'error': 'Database connection failed'}), 500

        cursor = connection.cursor(dictionary=True)

        # Fetch all status updates for this task, ordered by created_at desc
        cursor.execute("""
            SELECT id, task_id, task_name, task_status, reason, 
                   allocate_by, employee_id, assigned_date, target_date, 
                   created_at, updated_at
            FROM task_update
            WHERE task_id = %s
            ORDER BY created_at DESC
        """, (task_id,))
        
        status_history = cursor.fetchall()
        
        # Format dates for JSON response
        for status in status_history:
            for key, value in status.items():
                if isinstance(value, datetime):
                    status[key] = value.strftime('%Y-%m-%d %H:%M:%S')
                elif isinstance(value, date):
                    status[key] = value.strftime('%Y-%m-%d')

        cursor.close()
        connection.close()

        return jsonify({
            'success': True, 
            'history': status_history
        })
    
    except Exception as e:
        print(f"Error retrieving task status history: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/get_employee_incomplete_tasks/<employee_id>', methods=['GET'])
def get_employee_incomplete_tasks(employee_id):
    """Get all incomplete tasks assigned to a specific employee"""
    try:
        connection = get_db_connection()
        if not connection:
            return jsonify({'success': False, 'error': 'Database connection failed'}), 500

        cursor = connection.cursor(dictionary=True)

        # First, check if task_allocation table exists and has records for this employee
        try:
            # Get tasks from task_allocation table where this employee is assigned
            cursor.execute("""
                SELECT task_id, task_name, assigned_date, target_date
                FROM task_allocation
                WHERE employee_id = %s
            """, (employee_id,))
            
            allocations = cursor.fetchall()
            
            # Get the latest status of these tasks from task_update table
            task_statuses = {}
            if allocations:
                # Extract task IDs
                task_ids = [allocation['task_id'] for allocation in allocations]
                
                # Build placeholders for SQL IN clause
                placeholders = ', '.join(['%s'] * len(task_ids))
                
                # Query for latest status updates
                cursor.execute(f"""
                    SELECT t1.task_id, t1.task_name, t1.task_status, t1.reason, t1.created_at
                    FROM task_update t1
                    INNER JOIN (
                        SELECT task_id, MAX(created_at) as max_date
                        FROM task_update
                        WHERE task_id IN ({placeholders})
                        GROUP BY task_id
                    ) t2 ON t1.task_id = t2.task_id AND t1.created_at = t2.max_date
                """, task_ids)
                
                status_results = cursor.fetchall()
                
                # Store as dictionary for easy lookup
                for status in status_results:
                    task_statuses[status['task_id']] = status
            
            # Now, merge allocation and status data
            incomplete_tasks = []
            for allocation in allocations:
                task_id = allocation['task_id']
                
                # Skip tasks that are already completed
                if task_id in task_statuses and task_statuses[task_id]['task_status'] == 'Completed':
                    continue
                
                # Create task object with allocation and status data
                task = {
                    'task_id': task_id,
                    'task_name': allocation['task_name'],
                }
                
                # Add status if available
                if task_id in task_statuses:
                    task['task_status'] = task_statuses[task_id]['task_status']
                    task['reason'] = task_statuses[task_id]['reason']
                    task['updated_at'] = task_statuses[task_id]['created_at'].strftime('%Y-%m-%d %H:%M:%S') if isinstance(task_statuses[task_id]['created_at'], datetime) else task_statuses[task_id]['created_at']
                else:
                    task['task_status'] = 'Assigned'
                    task['reason'] = None
                    task['updated_at'] = None
                
                # Convert dates to strings if needed
                if allocation['assigned_date']:
                    if isinstance(allocation['assigned_date'], datetime):
                        task['assigned_date'] = allocation['assigned_date'].strftime('%Y-%m-%d')
                    else:
                        task['assigned_date'] = allocation['assigned_date']
                
                if allocation['target_date']:
                    if isinstance(allocation['target_date'], datetime):
                        task['target_date'] = allocation['target_date'].strftime('%Y-%m-%d')
                    else:
                        task['target_date'] = allocation['target_date']
                
                incomplete_tasks.append(task)
            
            # Now check for tasks in task_update table directly tied to this employee
            cursor.execute("""
                SELECT task_id, task_name, task_status, reason, created_at 
                FROM task_update
                WHERE employee_id = %s AND task_status != 'Completed'
                ORDER BY created_at DESC
            """, (employee_id,))
            
            direct_tasks = cursor.fetchall()
            
            # Process and add direct tasks (skipping duplicates)
            existing_task_ids = set(task['task_id'] for task in incomplete_tasks)
            
            for task in direct_tasks:
                if task['task_id'] not in existing_task_ids:
                    # Format dates
                    if isinstance(task['created_at'], datetime):
                        task['updated_at'] = task['created_at'].strftime('%Y-%m-%d %H:%M:%S')
                    else:
                        task['updated_at'] = task['created_at']
                    
                    # Remove created_at from the response
                    task.pop('created_at', None)
                    
                    incomplete_tasks.append(task)
                    existing_task_ids.add(task['task_id'])
            
            cursor.close()
            connection.close()
            
            return jsonify({
                'success': True,
                'tasks': incomplete_tasks
            })
            
        except Exception as e:
            print(f"Error querying task data: {e}")
            cursor.close()
            connection.close()
            return jsonify({'success': False, 'error': str(e)}), 500
            
    except Exception as e:
        print(f"Error retrieving incomplete tasks: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

# ================== TIMESHEET ROUTES ==================

@app.route('/api/timesheet/submit', methods=['POST'])
def submit_timesheet():
    """Submit a new timesheet entry"""
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['employeeId', 'employeeName', 'entryDate', 'inTime', 'outTime', 'totalHours']
        for field in required_fields:
            if field not in data:
                return jsonify({'success': False, 'error': f'Missing required field: {field}'}), 400
        
        # Format assigned tasks to JSON
        assigned_tasks = data.get('assignedTasks', [])
        assigned_tasks_json = []
        for task in assigned_tasks:
            assigned_tasks_json.append({
                'task_id': task.get('taskId', ''),
                'task_name': task.get('taskName', ''),
                'time_spent': float(task.get('timeSpent', 0)),
                'remarks': task.get('remarks', '')
            })
        
        # Format miscellaneous tasks to JSON
        misc_tasks = data.get('miscTasks', [])
        misc_tasks_json = []
        for task in misc_tasks:
            misc_tasks_json.append({
                'task_description': task.get('taskDescription', ''),
                'time_spent': float(task.get('timeSpent', 0)),
                'remarks': task.get('remarks', '')
            })
        
        # Connect to database
        conn = get_db_connection()
        if not conn:
            return jsonify({'success': False, 'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor()
        
        # Insert timesheet entry
        insert_query = """
            INSERT INTO time_sheet_entries (
                employee_id, employee_name, entry_date, in_time, out_time,
                total_hours, assigned_tasks, misc_tasks, status
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        values = (
            data['employeeId'],
            data['employeeName'],
            data['entryDate'],
            data['inTime'],
            data['outTime'],
            float(data['totalHours']),
            json.dumps(assigned_tasks_json),
            json.dumps(misc_tasks_json),
            data.get('status', 'pending')
        )
        
        cursor.execute(insert_query, values)
        entry_id = cursor.lastrowid
        conn.commit()
        
        cursor.close()
        conn.close()
        
        return jsonify({
            'success': True, 
            'message': 'Timesheet entry submitted successfully',
            'entryId': entry_id
        }), 201
        
    except Exception as e:
        print(f"Error submitting timesheet: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/timesheet/entries/<employee_id>', methods=['GET'])
def get_employee_timesheets(employee_id):
    """Get all timesheet entries for a specific employee"""
    try:
        # Get date filters if provided
        start_date = request.args.get('startDate')
        end_date = request.args.get('endDate')
        status = request.args.get('status')
        
        conn = get_db_connection()
        if not conn:
            return jsonify({'success': False, 'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor(dictionary=True)
        
        # Build query with optional filters
        query = "SELECT * FROM time_sheet_entries WHERE employee_id = %s"
        params = [employee_id]
        
        if start_date:
            query += " AND entry_date >= %s"
            params.append(start_date)
        
        if end_date:
            query += " AND entry_date <= %s"
            params.append(end_date)
        
        if status:
            query += " AND status = %s"
            params.append(status)
        
        query += " ORDER BY entry_date DESC"
        
        cursor.execute(query, params)
        entries = cursor.fetchall()
        
        # Convert dates and JSON strings to appropriate formats
        for entry in entries:
            if 'entry_date' in entry and entry['entry_date']:
                entry['entry_date'] = entry['entry_date'].strftime('%Y-%m-%d')
            
            # Format TIME fields that might be timedelta objects
            if 'in_time' in entry and entry['in_time']:
                if hasattr(entry['in_time'], 'strftime'):
                    entry['in_time'] = entry['in_time'].strftime('%H:%M:%S')
                elif hasattr(entry['in_time'], 'total_seconds'):
                    # Handle timedelta objects
                    total_seconds = int(entry['in_time'].total_seconds())
                    hours, remainder = divmod(total_seconds, 3600)
                    minutes, seconds = divmod(remainder, 60)
                    entry['in_time'] = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
            
            if 'out_time' in entry and entry['out_time']:
                if hasattr(entry['out_time'], 'strftime'):
                    entry['out_time'] = entry['out_time'].strftime('%H:%M:%S')
                elif hasattr(entry['out_time'], 'total_seconds'):
                    # Handle timedelta objects
                    total_seconds = int(entry['out_time'].total_seconds())
                    hours, remainder = divmod(total_seconds, 3600)
                    minutes, seconds = divmod(remainder, 60)
                    entry['out_time'] = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
            
            if 'approval_date' in entry and entry['approval_date']:
                entry['approval_date'] = entry['approval_date'].strftime('%Y-%m-%d %H:%M:%S')
            
            if 'created_at' in entry and entry['created_at']:
                entry['created_at'] = entry['created_at'].strftime('%Y-%m-%d %H:%M:%S')
            
            if 'updated_at' in entry and entry['updated_at']:
                entry['updated_at'] = entry['updated_at'].strftime('%Y-%m-%d %H:%M:%S')
            
            # Parse JSON fields
            if 'assigned_tasks' in entry and entry['assigned_tasks']:
                try:
                    entry['assigned_tasks'] = json.loads(entry['assigned_tasks'])
                except:
                    entry['assigned_tasks'] = []
            
            if 'misc_tasks' in entry and entry['misc_tasks']:
                try:
                    entry['misc_tasks'] = json.loads(entry['misc_tasks'])
                except:
                    entry['misc_tasks'] = []
        
        cursor.close()
        conn.close()
        
        return jsonify({
            'success': True,
            'entries': entries
        })
        
    except Exception as e:
        print(f"Error retrieving timesheet entries: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/timesheet/entry/<entry_id>', methods=['GET'])
def get_timesheet_entry(entry_id):
    """Get a specific timesheet entry by ID"""
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({'success': False, 'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor(dictionary=True)
        
        query = "SELECT * FROM time_sheet_entries WHERE entry_id = %s"
        cursor.execute(query, (entry_id,))
        
        entry = cursor.fetchone()
        
        if not entry:
            return jsonify({'success': False, 'error': 'Timesheet entry not found'}), 404
        
        # Format dates
        if 'entry_date' in entry and entry['entry_date']:
            entry['entry_date'] = entry['entry_date'].strftime('%Y-%m-%d')
        
        # Format TIME fields that might be timedelta objects
        if 'in_time' in entry and entry['in_time']:
            if hasattr(entry['in_time'], 'strftime'):
                entry['in_time'] = entry['in_time'].strftime('%H:%M:%S')
            elif hasattr(entry['in_time'], 'total_seconds'):
                # Handle timedelta objects
                total_seconds = int(entry['in_time'].total_seconds())
                hours, remainder = divmod(total_seconds, 3600)
                minutes, seconds = divmod(remainder, 60)
                entry['in_time'] = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
        
        if 'out_time' in entry and entry['out_time']:
            if hasattr(entry['out_time'], 'strftime'):
                entry['out_time'] = entry['out_time'].strftime('%H:%M:%S')
            elif hasattr(entry['out_time'], 'total_seconds'):
                # Handle timedelta objects
                total_seconds = int(entry['out_time'].total_seconds())
                hours, remainder = divmod(total_seconds, 3600)
                minutes, seconds = divmod(remainder, 60)
                entry['out_time'] = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
        
        if 'approval_date' in entry and entry['approval_date']:
            entry['approval_date'] = entry['approval_date'].strftime('%Y-%m-%d %H:%M:%S')
        
        if 'created_at' in entry and entry['created_at']:
            entry['created_at'] = entry['created_at'].strftime('%Y-%m-%d %H:%M:%S')
        
        if 'updated_at' in entry and entry['updated_at']:
            entry['updated_at'] = entry['updated_at'].strftime('%Y-%m-%d %H:%M:%S')
        
        # Parse JSON fields
        if 'assigned_tasks' in entry and entry['assigned_tasks']:
            try:
                entry['assigned_tasks'] = json.loads(entry['assigned_tasks'])
            except:
                entry['assigned_tasks'] = []
        
        if 'misc_tasks' in entry and entry['misc_tasks']:
            try:
                entry['misc_tasks'] = json.loads(entry['misc_tasks'])
            except:
                entry['misc_tasks'] = []
        
        cursor.close()
        conn.close()
        
        return jsonify({
            'success': True,
            'entry': entry
        })
        
    except Exception as e:
        print(f"Error retrieving timesheet entry: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/timesheet/entry/<entry_id>', methods=['PUT'])
def update_timesheet_entry(entry_id):
    """Update an existing timesheet entry"""
    try:
        data = request.get_json()
        
        conn = get_db_connection()
        if not conn:
            return jsonify({'success': False, 'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor()
        
        # Check if entry exists
        cursor.execute("SELECT entry_id FROM time_sheet_entries WHERE entry_id = %s", (entry_id,))
        if not cursor.fetchone():
            cursor.close()
            conn.close()
            return jsonify({'success': False, 'error': 'Timesheet entry not found'}), 404
        
        # Format assigned tasks to JSON if provided
        assigned_tasks_json = None
        if 'assignedTasks' in data:
            assigned_tasks = data['assignedTasks']
            assigned_tasks_json = []
            for task in assigned_tasks:
                assigned_tasks_json.append({
                    'task_id': task.get('taskId', ''),
                    'task_name': task.get('taskName', ''),
                    'time_spent': float(task.get('timeSpent', 0)),
                    'remarks': task.get('remarks', '')
                })
        
        # Format miscellaneous tasks to JSON if provided
        misc_tasks_json = None
        if 'miscTasks' in data:
            misc_tasks = data['miscTasks']
            misc_tasks_json = []
            for task in misc_tasks:
                misc_tasks_json.append({
                    'task_description': task.get('taskDescription', ''),
                    'time_spent': float(task.get('timeSpent', 0)),
                    'remarks': task.get('remarks', '')
                })
        
        # Build update query dynamically based on provided fields
        update_fields = []
        params = []
        
        field_mappings = {
            'employeeId': ('employee_id', None),
            'employeeName': ('employee_name', None),
            'entryDate': ('entry_date', None),
            'inTime': ('in_time', None),
            'outTime': ('out_time', None),
            'totalHours': ('total_hours', lambda x: float(x)),
            'status': ('status', None)
        }
        
        for frontend_field, db_info in field_mappings.items():
            db_field, transform_func = db_info
            if frontend_field in data:
                value = data[frontend_field]
                if transform_func:
                    value = transform_func(value)
                update_fields.append(f"{db_field} = %s")
                params.append(value)
        
        # Add JSON fields if they were provided
        if assigned_tasks_json is not None:
            update_fields.append("assigned_tasks = %s")
            params.append(json.dumps(assigned_tasks_json))
        
        if misc_tasks_json is not None:
            update_fields.append("misc_tasks = %s")
            params.append(json.dumps(misc_tasks_json))
        
        if not update_fields:
            return jsonify({'success': False, 'error': 'No fields to update'}), 400
        
        # Finalize query
        update_query = f"UPDATE time_sheet_entries SET {', '.join(update_fields)} WHERE entry_id = %s"
        params.append(entry_id)
        
        cursor.execute(update_query, params)
        conn.commit()
        
        cursor.close()
        conn.close()
        
        return jsonify({
            'success': True,
            'message': 'Timesheet entry updated successfully'
        })
        
    except Exception as e:
        print(f"Error updating timesheet entry: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/timesheet/entry/<entry_id>/status', methods=['PATCH'])
def update_timesheet_status(entry_id):
    """Update status of a timesheet entry"""
    try:
        data = request.get_json()
        
        if 'status' not in data:
            return jsonify({'success': False, 'error': 'Status field is required'}), 400
        
        status = data['status']
        if status not in ['pending', 'submitted', 'approved', 'rejected', 'revised']:
            return jsonify({'success': False, 'error': 'Invalid status value'}), 400
        
        conn = get_db_connection()
        if not conn:
            return jsonify({'success': False, 'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor()
        
        # Check if entry exists
        cursor.execute("SELECT entry_id FROM time_sheet_entries WHERE entry_id = %s", (entry_id,))
        if not cursor.fetchone():
            cursor.close()
            conn.close()
            return jsonify({'success': False, 'error': 'Timesheet entry not found'}), 404
        
        update_fields = ["status = %s"]
        params = [status]
        
        # Add approval info if status is 'approved'
        if status == 'approved':
            if 'approvedBy' not in data:
                return jsonify({'success': False, 'error': 'approvedBy field is required for approval'}), 400
            
            update_fields.append("approved_by = %s")
            update_fields.append("approval_date = NOW()")
            params.append(data['approvedBy'])
        
        # Add rejection reason if status is 'rejected'
        if status == 'rejected':
            if 'rejectionReason' not in data:
                return jsonify({'success': False, 'error': 'rejectionReason field is required for rejection'}), 400
            
            update_fields.append("rejection_reason = %s")
            params.append(data['rejectionReason'])
        
        # Finalize query
        update_query = f"UPDATE time_sheet_entries SET {', '.join(update_fields)} WHERE entry_id = %s"
        params.append(entry_id)
        
        cursor.execute(update_query, params)
        conn.commit()
        
        cursor.close()
        conn.close()
        
        return jsonify({
            'success': True,
            'message': f'Timesheet status updated to {status}'
        })
        
    except Exception as e:
        print(f"Error updating timesheet status: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/timesheet/pending-approval', methods=['GET'])
def get_pending_timesheets():
    """Get all timesheet entries pending approval"""
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({'success': False, 'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor(dictionary=True)
        
        query = """
            SELECT entry_id, employee_id, employee_name, entry_date, 
                   total_hours, created_at, updated_at
            FROM time_sheet_entries 
            WHERE status = 'submitted'
            ORDER BY entry_date DESC
        """
        
        cursor.execute(query)
        entries = cursor.fetchall()
        
        # Format dates
        for entry in entries:
            if 'entry_date' in entry and entry['entry_date']:
                entry['entry_date'] = entry['entry_date'].strftime('%Y-%m-%d')
            
            # Format TIME fields that might be timedelta objects
            if 'in_time' in entry and entry['in_time']:
                if hasattr(entry['in_time'], 'strftime'):
                    entry['in_time'] = entry['in_time'].strftime('%H:%M:%S')
                elif hasattr(entry['in_time'], 'total_seconds'):
                    # Handle timedelta objects
                    total_seconds = int(entry['in_time'].total_seconds())
                    hours, remainder = divmod(total_seconds, 3600)
                    minutes, seconds = divmod(remainder, 60)
                    entry['in_time'] = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
            
            if 'out_time' in entry and entry['out_time']:
                if hasattr(entry['out_time'], 'strftime'):
                    entry['out_time'] = entry['out_time'].strftime('%H:%M:%S')
                elif hasattr(entry['out_time'], 'total_seconds'):
                    # Handle timedelta objects
                    total_seconds = int(entry['out_time'].total_seconds())
                    hours, remainder = divmod(total_seconds, 3600)
                    minutes, seconds = divmod(remainder, 60)
                    entry['out_time'] = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
            
            if 'created_at' in entry and entry['created_at']:
                entry['created_at'] = entry['created_at'].strftime('%Y-%m-%d %H:%M:%S')
            
            if 'updated_at' in entry and entry['updated_at']:
                entry['updated_at'] = entry['updated_at'].strftime('%Y-%m-%d %H:%M:%S')
        
        cursor.close()
        conn.close()
        
        return jsonify({
            'success': True,
            'entries': entries
        })
        
    except Exception as e:
        print(f"Error retrieving pending timesheets: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/timesheet/project-mappings/<employee_id>', methods=['GET'])
def get_timesheet_project_mappings(employee_id):
    """Get project mappings for timesheet entries of a specific employee"""
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({'success': False, 'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor(dictionary=True)
        
        # Get all task allocations for this employee
        query = """
            SELECT 
                task_id, 
                project_name AS project_id, 
                client_name AS project_name
            FROM task_allocation 
            WHERE employee_id = %s
        """
        
        cursor.execute(query, (employee_id,))
        allocations = cursor.fetchall()
        
        # Create a mapping of task_id to project information
        task_project_map = {}
        for allocation in allocations:
            task_project_map[allocation['task_id']] = {
                'project_id': allocation['project_id'],
                'project_name': allocation['project_name']
            }
        
        cursor.close()
        conn.close()
        
        return jsonify({
            'success':  True,
            'employee_id': employee_id,
            'mappings': task_project_map
        })
        
    except Exception as e:
        print(f"Error retrieving project mappings: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/get_role_allocation/<allocation_id>', methods=['GET'])
def get_role_allocation(allocation_id):
    """Get a specific role allocation by ID"""
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        
        cursor = conn.cursor(dictionary=True)
        
        query = """
            SELECT * FROM employee_role_allocations 
            WHERE id = %s
        """
        
        cursor.execute(query, (allocation_id,))
        allocation = cursor.fetchone()
        
        if not allocation:
            return jsonify({"error": "Role allocation not found"}), 404
        
        # Format dates for consistent output
        if 'allocated_date' in allocation and allocation['allocated_date']:
            allocation['allocated_date'] = allocation['allocated_date'].strftime('%Y-%m-%d')
        
        cursor.close()
        conn.close()
        
        return jsonify(allocation), 200
    except Exception as e:
        print(f"Error getting role allocation: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/role_allocations', methods=['GET'])
def get_role_allocations():
    """Get all role allocations with optional filtering"""
    try:
        # Get query parameters for filtering
        employee_id = request.args.get('employee_id')
        role_id = request.args.get('role_id')
        from_date = request.args.get('from_date')
        to_date = request.args.get('to_date')
        limit = request.args.get('limit', 50, type=int)  # Default to 50 records
        
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        
        cursor = conn.cursor(dictionary=True)
        
        # Base query
        query = "SELECT * FROM employee_role_allocations WHERE 1=1"
        params = []
        
        # Add filters if provided
        if employee_id:
            query += " AND employee_id = %s"
            params.append(employee_id)
        
        if role_id:
            query += " AND role_id = %s"
            params.append(role_id)
        
        if from_date:
            query += " AND allocated_date >= %s"
            params.append(from_date)
        
        if to_date:
            query += " AND allocated_date <= %s"
            params.append(to_date)
        
        # Order by most recent allocations first
        query += " ORDER BY allocated_date DESC, id DESC LIMIT %s"
        params.append(limit)
        
        cursor.execute(query, params)
        allocations = cursor.fetchall()
        
        # Format dates for JSON response
        for allocation in allocations:
            if 'allocated_date' in allocation and allocation['allocated_date']:
                allocation['allocated_date'] = allocation['allocated_date'].strftime('%Y-%m-%d')
            if 'created_at' in allocation and allocation['created_at']:
                allocation['created_at'] = allocation['created_at'].strftime('%Y-%m-%d %H:%M:%S')
        
        # Get counts for statistics
        cursor.execute("SELECT COUNT(*) as total FROM employee_role_allocations")
        total_count = cursor.fetchone()['total']
        
        # Count recent allocations (last 30 days)
        cursor.execute(
            "SELECT COUNT(*) as recent FROM employee_role_allocations WHERE allocated_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)"
        )
        recent_count = cursor.fetchone()['recent']
        
        # Count by role for distribution
        cursor.execute(
            "SELECT role_id, COUNT(*) as count FROM employee_role_allocations GROUP BY role_id ORDER BY count DESC"
        )
        role_distribution = cursor.fetchall()
        
        cursor.close()
        conn.close()
        
        return jsonify({
            "allocations": allocations,
            "stats": {
                "total": total_count,
                "recent": recent_count,
                "roleDistribution": role_distribution
            }
        }), 200
    except Exception as e:
        print(f"Error getting role allocations: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/update_role_allocation', methods=['PUT'])
def update_role_allocation():
    """Update an existing role allocation"""
    data = request.get_json()
    
    # Required fields
    allocation_id = data.get('allocation_id')
    employee_id = data.get('employeeId')
    employee_name = data.get('employeeName')
    role_id = data.get('roleId')
    role_name = data.get('roleName')
    allocated_date = data.get('allocatedDate')
    reporting_person = data.get('reportingPerson', '')
    
    # Validate required fields
    if not all([allocation_id, employee_id, employee_name, role_id, role_name, allocated_date]):
        return jsonify({"error": "Missing required fields"}), 400
    
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        
        cursor = conn.cursor()
        
        # Check if allocation exists
        cursor.execute("SELECT id FROM employee_role_allocations WHERE id = %s", (allocation_id,))
        if not cursor.fetchone():
            cursor.close()
            conn.close()
            return jsonify({"error": "Role allocation not found"}), 404
        
        # Update the allocation
        query = """
            UPDATE employee_role_allocations 
            SET employee_id = %s,
                employee_name = %s,
                role_id = %s,
                role_name = %s,
                allocated_date = %s,
                reporting_person = %s
            WHERE id = %s
        """
        
        cursor.execute(query, (
            employee_id,
            employee_name,
            role_id,
            role_name,
            allocated_date,
            reporting_person,
            allocation_id
        ))
        
        conn.commit()
        cursor.close()
        conn.close()
        
        return jsonify({"message": "Role allocation updated successfully"}), 200
    except Exception as e:
        print(f"Error updating role allocation: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/role_allocations_stats', methods=['GET'])
def get_role_allocations_stats():
    """Get statistics about role allocations"""
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        
        cursor = conn.cursor(dictionary=True)
        
        # Get total count
        cursor.execute("SELECT COUNT(*) as total FROM employee_role_allocations")
        total_count = cursor.fetchone()['total']
        
        # Get recent count (last 30 days)
        cursor.execute(
            "SELECT COUNT(*) as recent FROM employee_role_allocations WHERE allocated_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)"
        )
        recent_count = cursor.fetchone()['recent']
        
        # Get role distribution
        cursor.execute(
            "SELECT role_id, COUNT(*) as count FROM employee_role_allocations GROUP BY role_id ORDER BY count DESC LIMIT 5"
        )
        role_distribution = cursor.fetchall()
        
        # Get trend data (allocations per month for the last 6 months)
        cursor.execute("""
            SELECT 
                DATE_FORMAT(allocated_date, '%Y-%m') as month,
                COUNT(*) as count
            FROM employee_role_allocations
            WHERE allocated_date >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)
            GROUP BY DATE_FORMAT(allocated_date, '%Y-%m')
            ORDER BY month
        """)
        trend_data = cursor.fetchall()
        
        cursor.close()
        conn.close()
        
        return jsonify({
            "total": total_count,
            "recent": recent_count,
            "pending": 0,  # Placeholder for future implementation
            "roleDistribution": role_distribution,
            "trend": trend_data
        }), 200
    except Exception as e:
        print(f"Error getting role allocation stats: {e}")
        return jsonify({"error": str(e)}), 500

def init_db():
    """Initialize the database with required tables"""
    conn = get_db_connection()
    if not conn:
        return
    
    cursor = conn.cursor()
    
    # Create employees table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS employees (
        id INT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(100) NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        phone VARCHAR(20),
        department VARCHAR(50),
        position VARCHAR(50),
        joining_date DATE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
    )
    ''')
    
    # Create roles table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS roles (
        id INT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(100) NOT NULL,
        description TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
    )
    ''')
    
    # Create employee_role_allocations table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS employee_role_allocations (
        id INT AUTO_INCREMENT PRIMARY KEY,
        employee_id INT NOT NULL,
        employee_name VARCHAR(100) NOT NULL,
        role_id INT NOT NULL,
        role_name VARCHAR(100) NOT NULL,
        allocated_date DATE NOT NULL,
        reporting_person VARCHAR(100),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        FOREIGN KEY (employee_id) REFERENCES employees(id),
        FOREIGN KEY (role_id) REFERENCES roles(id)
    )
    ''')
    
    conn.commit()
    cursor.close()
    conn.close()

@app.route('/api/role_allocations', methods=['POST'])
def allocate_role_api():
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "No data provided"}), 400

        # Extract data from request
        employee_id = data.get('employeeId')
        employee_name = data.get('employeeName')
        role_id = data.get('roleId')
        role_name = data.get('roleName')
        allocated_date = data.get('allocatedDate')
        reporting_person = data.get('reportingPerson', '')
        additional_employee_id = data.get('additionalEmployeeId', '')
        additional_employee_name = data.get('additionalEmployeeName', '')

        # Validate required fields
        if not all([employee_id, employee_name, role_id, role_name, allocated_date]):
            return jsonify({"error": "Missing required fields"}), 400

        # Format date for database
        allocated_date = format_date_for_db(allocated_date)

        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        
        cursor = conn.cursor()
        
        # Insert into employee_role_allocations table
        query = """
            INSERT INTO employee_role_allocations 
            (employee_id, employee_name, role_id, role_name, allocated_date, reporting_person, additional_employee_id, additional_employee_name)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        cursor.execute(query, (
            employee_id,
            employee_name,
            role_id,
            role_name,
            allocated_date,
            reporting_person,
            additional_employee_id,
            additional_employee_name
        ))
        
        # Also update the employee's role in the employees table
        try:
            update_query = """
                UPDATE employees 
                SET role_id = %s, role_name = %s
                WHERE employee_id = %s
            """
            
            cursor.execute(update_query, (role_id, role_name, employee_id))
            print(f"API: Updated employee {employee_id} with role {role_name}")
        except Exception as update_error:
            print(f"API: Error updating employee role in employees table: {update_error}")
            # Continue even if this update fails - the allocation is still valid
        
        conn.commit()
        cursor.close()
        conn.close()
        
        return jsonify({"message": "Role allocation saved successfully"}), 200
    except Exception as e:
        print(f"Error allocating role: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/role_allocations/<allocation_id>', methods=['DELETE'])
def delete_role_allocation(allocation_id):
    """Delete a role allocation by ID"""
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed."}), 500
        
        cursor = conn.cursor()
        
        # Check if allocation exists
        cursor.execute("SELECT id FROM employee_role_allocations WHERE id = %s", (allocation_id,))
        if not cursor.fetchone():
            cursor.close()
            conn.close()
            return jsonify({"error": "Role allocation not found"}), 404
        
        # Delete the allocation
        cursor.execute("DELETE FROM employee_role_allocations WHERE id = %s", (allocation_id,))
        conn.commit()
        
        cursor.close()
        conn.close()
        
        return jsonify({"message": "Role allocation deleted successfully"}), 200
    except Exception as e:
        print(f"Error deleting role allocation: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/timesheet-summary', methods=['POST'])
def save_timesheet_summary():
    """Save a timesheet entry to the time_sheet_summary table"""
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['employee_id', 'employee_name', 'entry_date', 'in_time', 'out_time', 'total_hours']
        for field in required_fields:
            if field not in data:
                return jsonify({'success': False, 'error': f'Missing required field: {field}'}), 400
        
        # Connect to database
        conn = get_db_connection()
        if not conn:
            return jsonify({'success': False, 'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor()
        
        # Check if an entry for this employee, date, and task already exists
        check_query = """
            SELECT summary_id FROM time_sheet_summary 
            WHERE employee_id = %s AND entry_date = %s 
            AND (task_id = %s OR (task_id IS NULL AND %s IS NULL))
        """
        
        cursor.execute(check_query, (
            data['employee_id'], 
            data['entry_date'],
            data.get('task_id'),
            data.get('task_id')
        ))
        
        existing_entry = cursor.fetchone()
        
        if existing_entry:
            # Update existing entry
            update_query = """
                UPDATE time_sheet_summary SET
                employee_name = %s,
                task_name = %s,
                project_id = %s,
                in_time = %s,
                out_time = %s,
                total_hours = %s,
                updated_at = CURRENT_TIMESTAMP
                WHERE summary_id = %s
            """
            
            values = (
                data['employee_name'],
                data.get('task_name'),
                data.get('project_id'),
                data['in_time'],
                data['out_time'],
                float(data['total_hours']),
                existing_entry[0]
            )
            
            cursor.execute(update_query, values)
            summary_id = existing_entry[0]
            message = 'Timesheet summary updated successfully'
        else:
            # Insert new entry
            insert_query = """
                INSERT INTO time_sheet_summary (
                    employee_id, employee_name, task_id, task_name,
                    project_id, entry_date, in_time, out_time, total_hours
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            
            values = (
                data['employee_id'],
                data['employee_name'],
                data.get('task_id'),
                data.get('task_name'),
                data.get('project_id'),
                data['entry_date'],
                data['in_time'],
                data['out_time'],
                float(data['total_hours'])
            )
            
            cursor.execute(insert_query, values)
            summary_id = cursor.lastrowid
            message = 'Timesheet summary saved successfully'
        
        conn.commit()
        cursor.close()
        conn.close()
        
        return jsonify({
            'success': True, 
            'message': message,
            'summary_id': summary_id
        }), 201
        
    except Exception as e:
        print(f"Error saving timesheet summary: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/timesheet-summary/<employee_id>', methods=['GET'])
def get_timesheet_summary(employee_id):
    """Get timesheet summary entries for a specific employee"""
    try:
        # Connect to database
        conn = get_db_connection()
        if not conn:
            return jsonify({'success': False, 'error': 'Database connection failed'}), 500
        
        cursor = conn.cursor()
        
        # Optional date range filtering
        start_date = request.args.get('startDate')
        end_date = request.args.get('endDate')
        
        query = "SELECT * FROM time_sheet_summary WHERE employee_id = %s"
        params = [employee_id]
        
        if start_date:
            query += " AND entry_date >= %s"
            params.append(start_date)
            
        if end_date:
            query += " AND entry_date <= %s"
            params.append(end_date)
            
        query += " ORDER BY entry_date DESC"
        
        cursor.execute(query, params)
        results = cursor.fetchall()
        
        column_names = [desc[0] for desc in cursor.description]
        summaries = []
        
        for row in results:
            summary = dict(zip(column_names, row))
            # Convert decimal and datetime objects to serializable format
            if 'total_hours' in summary and summary['total_hours'] is not None:
                summary['total_hours'] = float(summary['total_hours'])
                
            if 'entry_date' in summary and summary['entry_date'] is not None:
                summary['entry_date'] = summary['entry_date'].strftime('%Y-%m-%d')
                
            if 'in_time' in summary and summary['in_time'] is not None:
                summary['in_time'] = summary['in_time'].strftime('%H:%M')
                
            if 'out_time' in summary and summary['out_time'] is not None:
                summary['out_time'] = summary['out_time'].strftime('%H:%M')
                
            if 'created_at' in summary and summary['created_at'] is not None:
                summary['created_at'] = summary['created_at'].strftime('%Y-%m-%d %H:%M:%S')
                
            if 'updated_at' in summary and summary['updated_at'] is not None:
                summary['updated_at'] = summary['updated_at'].strftime('%Y-%m-%d %H:%M:%S')
                
            summaries.append(summary)
        
        cursor.close()
        conn.close()
        
        return jsonify({
            'success': True,
            'summaries': summaries
        })
        
    except Exception as e:
        print(f"Error fetching timesheet summaries: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/export-employee/<employee_id>/<format>', methods=['GET'])
def export_employee_profile(employee_id, format):
    """
    Export employee profile as CSV or PDF
    
    Args:
        employee_id: The employee ID to export
        format: The format to export (csv or pdf)
    
    Returns:
        A CSV or PDF file with the employee's information
    """
    try:
        print(f"Exporting employee profile for ID: {employee_id} in format: {format}")
        
        # Get employee data
        try:
            print(f"Executing simple query: SELECT * FROM employees WHERE employee_id = %s")
            
            conn = get_db_connection()
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM employees WHERE employee_id = %s", (employee_id,))
            employee_data = cursor.fetchone()
            
            cursor.close()
            conn.close()
            
            if not employee_data:
                return jsonify({"error": f"Employee with ID {employee_id} not found"}), 404
        except Exception as e:
            print(f"Database error: {e}")
            return jsonify({"error": "Failed to fetch employee data from database"}), 500
        
        # Export the employee data based on the requested format
        if format.lower() == 'csv':
            # Create a CSV file
            csv_output = StringIO()
            csv_writer = csv.writer(csv_output)
            
            # Write employee data to CSV
            for key in sorted(employee_data.keys()):
                if key != 'profile_photo':  # Skip binary data
                    field_name = key.replace('_', ' ').title()
                    csv_writer.writerow([field_name, employee_data[key]])
            
            # Create a response
            response = make_response(csv_output.getvalue())
            response.headers['Content-Type'] = 'text/csv'
            response.headers['Content-Disposition'] = f'attachment; filename=employee_{employee_id}.csv'
            
            # Try to log the download but don't fail if this fails
            try:
                log_download('employee', employee_id, 'csv', 1)
            except Exception as log_err:
                logger = logging.getLogger(__name__)
                logger.warning(f"Error logging download: {str(log_err)}")
            
            return response
            
        elif format.lower() == 'pdf':
            # Create a PDF
            buffer = BytesIO()
            doc = SimpleDocTemplate(buffer, pagesize=A4, 
                                  leftMargin=0.5*inch, rightMargin=0.5*inch,
                                  topMargin=0.5*inch, bottomMargin=0.5*inch)
            styles = getSampleStyleSheet()
            elements = []
            
            # Define custom styles
            title_style = ParagraphStyle(
                'Title',
                parent=styles['Heading1'],
                alignment=1,  # Centered
                spaceAfter=10,
                textColor=colors.HexColor('#1e3a8a'),  # Dark blue
                fontSize=20,
                fontName='Helvetica-Bold',
                leading=24  # Line height
            )
            
            subtitle_style = ParagraphStyle(
                'Subtitle',
                parent=styles['Heading2'],
                alignment=1,  # Centered
                spaceBefore=0,
                spaceAfter=20,
                textColor=colors.HexColor('#475569'),  # Slate gray
                fontSize=12,
                fontName='Helvetica-Oblique'
            )
            
            section_style = ParagraphStyle(
                'Section',
                parent=styles['Heading3'],
                textColor=colors.HexColor('#1e3a8a'),
                fontSize=14,
                fontName='Helvetica-Bold',
                spaceBefore=15,
                spaceAfter=10,
                leftIndent=5
            )
            
            footer_style = ParagraphStyle(
                'Footer',
                parent=styles['Normal'],
                alignment=1,  # Centered
                textColor=colors.HexColor('#64748b'),  # Light slate
                fontSize=8,
                fontName='Helvetica-Oblique'
            )
            
            # Get employee name - try multiple fields
            if 'name' in employee_data:
                employee_name = employee_data['name']
            elif 'first_name' in employee_data and 'last_name' in employee_data:
                employee_name = f"{employee_data['first_name']} {employee_data['last_name']}"
            else:
                employee_name = f"Employee {employee_id}"
            
            # Add header with company logo (if available)
            image_path = os.path.join(os.path.dirname(__file__), 'static', 'company_logo.png')
            if os.path.exists(image_path):
                logo = Image(image_path, width=1.5*inch, height=0.5*inch)
                elements.append(logo)
                elements.append(Spacer(1, 0.1*inch))
            
            # Add title and employee ID subtitle    
            elements.append(Paragraph(f"Employee Profile: {employee_name}", title_style))
            elements.append(Paragraph(f"ID: {employee_id}", subtitle_style))
            
            # Add a simpler horizontal line as a rectangle
            elements.append(Spacer(1, 10))
            # Create a rectangle using a table instead of Flowable
            t = Table([['']], colWidths=[500], rowHeights=[2])
            t.setStyle(TableStyle([('BACKGROUND', (0, 0), (0, 0), colors.HexColor('#1e3a8a'))]))
            elements.append(t)
            elements.append(Spacer(1, 15))
            
            # Organize data into sections
            personal_info = []
            contact_info = []
            employment_info = []
            other_info = []
            
            # Fields for each section
            personal_fields = ['first_name', 'last_name', 'dob', 'gender', 'nationality', 
                            'marital_status', 'father_name', 'mother_name', 'spouse_name']
            
            contact_fields = ['email', 'mobile', 'alt_mobile', 'alternate_mobile', 'emergency_mobile', 
                            'permanent_address', 'communication_address', 'address']
            
            employment_fields = ['employee_id', 'role_name', 'roleName', 'department', 
                                'doj', 'joining_date', 'joining_location', 'qualification']
            
            # Sort data into sections
            for key, value in employee_data.items():
                key_lower = key.lower()
                if key != 'profile_photo' and value:  # Skip empty fields and binary data
                    field_name = key.replace('_', ' ').title()
                    value_str = str(value)
                    
                    if any(field in key_lower for field in personal_fields):
                        personal_info.append([field_name, value_str])
                    elif any(field in key_lower for field in contact_fields):
                        contact_info.append([field_name, value_str])
                    elif any(field in key_lower for field in employment_fields):
                        employment_info.append([field_name, value_str])
                    else:
                        other_info.append([field_name, value_str])
            
            # Function to create and style a table for a section
            def create_section_table(data, title):
                if not data:
                    return None
                
                elements.append(Paragraph(title, section_style))
                
                # Sort data alphabetically by field name
                data.sort(key=lambda x: x[0])
            
                # Create the table
                table = Table(data, colWidths=[2*inch, 4*inch])
                
                # Define table style
                table_style = TableStyle([
                    ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f1f5f9')),  # Light blue-gray
                    ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#334155')),  # Dark slate
                    ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ('FONT', (0, 0), (0, -1), 'Helvetica-Bold'),
                    ('FONT', (1, 0), (1, -1), 'Helvetica'),
                    ('FONTSIZE', (0, 0), (-1, -1), 10),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 7),
                    ('TOPPADDING', (0, 0), (-1, -1), 7),
                    ('LEFTPADDING', (0, 0), (-1, -1), 10),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 10),
                    ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#cbd5e1')),  # Light gray for grid
                    ('BOX', (0, 0), (-1, -1), 1, colors.HexColor('#94a3b8')),  # Slate border
                ])
                
                # Zebra stripe pattern for better readability
                for i in range(len(data)):
                    if i % 2 == 1:
                        table_style.add('BACKGROUND', (0, i), (-1, i), colors.HexColor('#f8fafc'))  # Lighter blue-gray
                
                table.setStyle(table_style)
                elements.append(table)
                elements.append(Spacer(1, 0.1*inch))
                return table
            
            # Add each section to the PDF
            if employment_info:
                create_section_table(employment_info, "Employment Information")
            
            if personal_info:
                create_section_table(personal_info, "Personal Information")
            
            if contact_info:
                create_section_table(contact_info, "Contact Information")
            
            if other_info:
                create_section_table(other_info, "Additional Information")
            
            # Add a footer with date and page numbers
            elements.append(Spacer(1, 0.5*inch))
            # Use a table instead of Flowable to create a line
            t2 = Table([['']], colWidths=[500], rowHeights=[1])
            t2.setStyle(TableStyle([('BACKGROUND', (0, 0), (0, 0), colors.HexColor('#94a3b8'))]))
            elements.append(t2)
            elements.append(Spacer(1, 5))
            
            footer_text = f"Generated on {datetime.now().strftime('%d %b %Y %H:%M')} â€¢ Confidential Employee Information"
            elements.append(Paragraph(footer_text, footer_style))
            
            # Build the PDF
            doc.build(elements)
            buffer.seek(0)
            
            # Create a response
            response = make_response(buffer.getvalue())
            response.headers['Content-Type'] = 'application/pdf'
            response.headers['Content-Disposition'] = f'attachment; filename=employee_{employee_id}.pdf'
            
            # Try to log the download but don't fail if this fails
            try:
                log_download('employee', employee_id, 'pdf', 1)
            except Exception as log_err:
                logger = logging.getLogger(__name__)
                logger.warning(f"Error logging download: {str(log_err)}")
            
            return response
        
        else:
            return jsonify({"error": f"Unsupported format: {format}. Use 'pdf' or 'csv'."}), 400
        
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"Error exporting employee profile: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        
        # Return a clean error message
        return jsonify({"error": "Failed to export employee profile. Please try again later."}), 500@app.route('/api/employee-assignments/<employee_id>', methods=['GET'])
def get_employee_assignments(employee_id):
    """
    Get assignments for a specific employee including role allocations and task allocations
    
    Args:
        employee_id: The employee ID to get assignments for
        
    Returns:
        JSON response with the employee's assignments
    """
    try:
        print(f"Fetching assignments for employee with ID: {employee_id}")
        
        # Default response structure with empty arrays
        response = {
            "role_allocations": [],
            "task_allocations": [],
            "total_monthly_hours": 0,
            "active_projects_count": 0,
            "active_tasks_count": 0
        }
        
        # Get database connection
        conn = get_db_connection()
        if not conn:
            return jsonify(response), 200  # Return empty response instead of error
            
        cursor = conn.cursor(dictionary=True)
        
        # Check if the employee exists first
        cursor.execute("SELECT * FROM employees WHERE employee_id = %s", (employee_id,))
        employee = cursor.fetchone()
        
        if not employee:
            cursor.close()
            conn.close()
            return jsonify(response), 200  # Return empty response if employee not found
        
        try:
            # Try to get role allocations - handle if table doesn't exist
            cursor.execute("""
                SELECT 
                    era.id as allocation_id,
                    era.role_id,
                    era.role_name,
                    p.project_id,
                    p.project_name,
                    p.status as project_status,
                    c.client_name,
                    era.allocated_date as start_date,
                    NULL as end_date,
                    COALESCE(era.workload_percentage, 100) as workload_percentage
                FROM employee_role_allocations era
                LEFT JOIN projects p ON era.project_id = p.project_id
            LEFT JOIN clients c ON p.client_id = c.client_id
                WHERE era.employee_id = %s
                ORDER BY era.allocated_date DESC
            """, (employee_id,))
            
            role_allocations = cursor.fetchall()
            
            # Format dates in role allocations
            for allocation in role_allocations:
                if allocation.get('start_date') and isinstance(allocation['start_date'], (date, datetime)):
                    allocation['start_date'] = allocation['start_date'].strftime('%Y-%m-%d')
                if allocation.get('end_date') and isinstance(allocation['end_date'], (date, datetime)):
                    allocation['end_date'] = allocation['end_date'].strftime('%Y-%m-%d')
            
            response["role_allocations"] = role_allocations
        except Exception as e:
            print(f"Error fetching role allocations: {e}")
            # Continue with empty role_allocations rather than failing
        
        try:
            # Try to get task allocations - handle if table doesn't exist
            cursor.execute("""
                SELECT 
                    ta.id as allocation_id,
                    t.task_id,
                    t.task_name,
                    t.description,
                    t.status as task_status,
                    p.project_id,
                    p.project_name,
                    ta.allocated_date as start_date,
                    t.target_completion_date as end_date,
                    t.priority
                FROM task_allocations ta
                JOIN tasks t ON ta.task_id = t.task_id
                LEFT JOIN projects p ON t.project_id = p.project_id
                WHERE ta.employee_id = %s
                ORDER BY t.target_completion_date ASC
            """, (employee_id,))
            
            task_allocations = cursor.fetchall()
            
            # Format dates in task allocations
            for task in task_allocations:
                if task.get('start_date') and isinstance(task['start_date'], (date, datetime)):
                    task['start_date'] = task['start_date'].strftime('%Y-%m-%d')
                if task.get('end_date') and isinstance(task['end_date'], (date, datetime)):
                    task['end_date'] = task['end_date'].strftime('%Y-%m-%d')
            
            response["task_allocations"] = task_allocations
            response["active_tasks_count"] = len([t for t in task_allocations if t.get('task_status', '').lower() not in ('completed', 'cancelled')])
        except Exception as e:
            print(f"Error fetching task allocations: {e}")
            # Continue with empty task_allocations rather than failing
        
        try:
            # Get statistics data
            current_month = datetime.now().month
            current_year = datetime.now().year
            
            # Try to get monthly hours from timesheet summary
            cursor.execute("""
                SELECT SUM(total_hours) as total_hours
                FROM time_sheet_summary
            WHERE employee_id = %s
                  AND MONTH(entry_date) = %s
                  AND YEAR(entry_date) = %s
            """, (employee_id, current_month, current_year))
            
            hours_result = cursor.fetchone()
            if hours_result and hours_result['total_hours']:
                response["total_monthly_hours"] = float(hours_result['total_hours'])
                
            # Count active projects
            cursor.execute("""
                SELECT COUNT(DISTINCT p.project_id) as project_count
                FROM employee_role_allocations era
                JOIN projects p ON era.project_id = p.project_id
                WHERE era.employee_id = %s
                  AND p.status IN ('Active', 'In Progress')
            """, (employee_id,))
            
            project_count = cursor.fetchone()
            if project_count and project_count['project_count']:
                response["active_projects_count"] = int(project_count['project_count'])
        except Exception as e:
            print(f"Error fetching statistics: {e}")
            # Continue with default statistics rather than failing
        
        cursor.close()
        conn.close()
        
        return jsonify(response), 200
        
    except Exception as e:
        print(f"Error fetching employee assignments: {str(e)}")
        # Return default empty response structure instead of error
        return jsonify({
            "role_allocations": [],
            "task_allocations": [],
            "total_monthly_hours": 0,
            "active_projects_count": 0,
            "active_tasks_count": 0
        }), 200

@app.route('/api/employees/<employee_id>', methods=['PUT'])
def update_employee(employee_id):
    """Update an employee's details
    
    Args:
        employee_id: The ID of the employee to update
        
    Returns:
        A JSON response with the result of the update operation
    """
    try:
        print(f"Updating employee with ID: {employee_id}")
        
        # Get update data from request
        data = request.get_json()
        if not data:
            return jsonify({"error": "No data provided"}), 400
            
        # Get database connection
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed"}), 500
            
        cursor = conn.cursor(dictionary=True)
        
        # First check if employee exists
        cursor.execute("SELECT * FROM employees WHERE employee_id = %s", (employee_id,))
        employee = cursor.fetchone()
        
        if not employee:
            cursor.close()
            conn.close()
            return jsonify({"error": f"Employee with ID {employee_id} not found"}), 404
            
        # Prepare the update query
        update_fields = []
        update_values = []
        
        # Map the frontend field names to database column names
        field_mapping = {
            'firstName': 'first_name',
            'lastName': 'last_name',
            'first_name': 'first_name',
            'last_name': 'last_name',
            'dob': 'dob',
            'gender': 'gender',
            'nationality': 'nationality',
            'permanentAddress': 'permanent_address',
            'permanent_address': 'permanent_address',
            'communicationAddress': 'communication_address',
            'communication_address': 'communication_address',
            'address': 'permanent_address',  # Map general address to permanent address
            'mobile': 'mobile',
            'altMobile': 'alt_mobile',
            'alt_mobile': 'alt_mobile',
            'email': 'email',
            'qualification': 'qualification',
            'department': 'department',
            'emergencyContactPerson': 'emergency_contact_person',
            'emergency_contact_person': 'emergency_contact_person',
            'emergencyMobile': 'emergency_contact_no',
            'emergency_mobile': 'emergency_contact_no',
            'emergencyRelationship': 'emergency_relationship',
            'emergency_relationship': 'emergency_relationship',
            'fatherName': 'father_name',
            'father_name': 'father_name',
            'motherName': 'mother_name',
            'mother_name': 'mother_name',
            'maritalStatus': 'marital_status',
            'marital_status': 'marital_status',
            'spouseName': 'spouse_name',
            'spouse_name': 'spouse_name',
            'joiningLocation': 'joining_location',
            'joining_location': 'joining_location',
            'doj': 'doj',
            'profile_photo': 'profile_pic',
            'profilePic': 'profile_pic',
            'role_name': 'role_name',
            'roleName': 'role_name',
            'status': 'status'
        }
        
        # Check which columns actually exist in the employees table
        cursor.execute("DESCRIBE employees")
        columns = cursor.fetchall()
        valid_columns = [col['Field'] for col in columns]
        
        print(f"Valid database columns: {valid_columns}")
        
        # Process each field in the request data
        for key, value in data.items():
            # Skip fields that aren't mapped to database columns
            if key not in field_mapping:
                continue
                
            db_column = field_mapping[key]
            
            # Skip if the database column doesn't exist
            if db_column not in valid_columns:
                continue
                
            # Add to the update query
            update_fields.append(f"{db_column} = %s")
            update_values.append(value)
        
        # If no valid fields to update
        if not update_fields:
            cursor.close()
            conn.close()
            return jsonify({"message": "No valid fields to update"}), 200
            
        # Construct the update query
        query = f"""
            UPDATE employees 
            SET {', '.join(update_fields)}
            WHERE employee_id = %s
        """
        
        # Add the employee_id to the values
        update_values.append(employee_id)
        
        # Execute the update
        print(f"Executing update query: {query}")
        print(f"With values: {update_values}")
        
        cursor.execute(query, update_values)
        conn.commit()
                
        # Get the updated employee data
        cursor.execute("SELECT * FROM employees WHERE employee_id = %s", (employee_id,))
        updated_employee = cursor.fetchone()
        
        # Format date fields
        for key, value in updated_employee.items():
            if isinstance(value, (date, datetime)):
                updated_employee[key] = value.strftime('%Y-%m-%d')
        
        cursor.close()
        conn.close()
        
        return jsonify({
            "message": "Employee updated successfully",
            "employee": updated_employee
        }), 200
        
    except Exception as e:
        print(f"Error updating employee: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/employees/<employee_id>/profile-image', methods=['POST'])
def upload_profile_image(employee_id):
    """
    Upload a profile image for a specific employee.
    Expects a multipart/form-data request with a 'profilePic' file.
    
    Args:
        employee_id: The ID of the employee to update
        
    Returns:
        A JSON response with the result of the upload operation
    """
    try:
        print(f"Uploading profile image for employee with ID: {employee_id}")
        
        # Check if the employee exists first
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed"}), 500
            
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT * FROM employees WHERE employee_id = %s", (employee_id,))
        employee = cursor.fetchone()
        
        if not employee:
            cursor.close()
            conn.close()
            return jsonify({"error": f"Employee with ID {employee_id} not found"}), 404
        
        # Check if there's a file in the request
        if 'profilePic' not in request.files:
            return jsonify({"error": "No file part in the request"}), 400
            
        file = request.files['profilePic']
        
        # If the user did not select a file
        if file.filename == '':
            return jsonify({"error": "No file selected"}), 400
            
        # Check if the file has an allowed extension
        if not allowed_file(file.filename):
            return jsonify({"error": "Invalid file type. Only PNG, JPG, JPEG allowed."}), 400
            
        # Generate a unique filename
        ext = file.filename.rsplit('.', 1)[1].lower()
        unique_name = f"profile_{employee_id}_{uuid.uuid4().hex}.{ext}"
        
        # Create upload folder if it doesn't exist
        if not os.path.exists(app.config['UPLOAD_FOLDER']):
            os.makedirs(app.config['UPLOAD_FOLDER'])
            
        # Save the file
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], unique_name)
        file.save(filepath)
        
        # Update the employee record with the new profile picture
        update_query = "UPDATE employees SET profile_pic = %s WHERE employee_id = %s"
        cursor.execute(update_query, (unique_name, employee_id))
        conn.commit()
        
        cursor.close()
        conn.close()
        
        # Return success response with the filename
        return jsonify({
            "message": "Profile image uploaded successfully",
            "filename": unique_name,
            "url": url_for('uploaded_file', filename=unique_name, _external=True)
        }), 200
        
    except Exception as e:
        print(f"Error uploading profile image: {str(e)}")
        # If there was a connection, close it
        if 'conn' in locals() and conn.is_connected():
            cursor.close()
            conn.close()
        return jsonify({"error": str(e)}), 500



if __name__ == "__main__":
    # Create required tables when app starts
    create_tables()
    app.run(debug=True, port=5001)